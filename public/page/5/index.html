
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <title>DD_XIE的学习笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="">
    <meta name="description" content="前端学习">
    
        <link rel="icon" href="/favicon.ico">
    
    
        
            <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
        
            <link rel="stylesheet" href="/css/stage.css">
        
            <link rel="stylesheet" href="/css/avatar-bg.css">
        
    
</head>
</html>
<body>
<header id="header">
    <div class="menu">
        <i class="fa fa-bars"></i>
    </div>
    <div class="header-main">
        <h1><a href="/">DD_XIE的学习笔记</a></h1>
    </div>
    <div id="nav">
        <div class="nav-img" id="nav-img"></div>
        <div class="sentences">
            云里写诗，泥里生活，岁月里洒脱。
        </div>
    </div>
</header>

<div id="content-outer">
    <div id="content-inner">
        <div class="clearfix">
    
    <div id="recent-posts">
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/13/vue/">
                        VUE
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-07-13T13:35:13.000Z">
                            2019-07-13
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/VUE/">VUE</a></li></ul>
                </div>
                
                    <h1 id="IntellIJ-IDEA-配置支持Vue"><a href="#IntellIJ-IDEA-配置支持Vue" class="headerlink" title="IntellIJ IDEA 配置支持Vue"></a>IntellIJ IDEA 配置支持Vue</h1><p>参考：<a href="https://www.jianshu.com/p/01d832e028ea" target="_blank" rel="noopener">https://www.jianshu.com/p/01d832e028ea</a><br>第一步：先安装vue插件:<br>file –&gt; settings –&gt; plugins，然后什么都不用输入，直接点击Browse repositories… 紧接着左上方输入“vue”，点击搜索结果里的vue.js，右边会有绿色install按钮，安装成功后重启idea，这样idea就能识别.vue文件了。<br>第二步：设置vue新建文件模板。</p>
<h1 id="安装Element-ui"><a href="#安装Element-ui" class="headerlink" title="安装Element-ui"></a>安装Element-ui</h1><h1 id="vue2-0-element-UI-中-el-table-数据导出Excel"><a href="#vue2-0-element-UI-中-el-table-数据导出Excel" class="headerlink" title="vue2.0 + element UI 中 el-table 数据导出Excel"></a>vue2.0 + element UI 中 el-table 数据导出Excel</h1><p>最近后台项目中有需要将游戏用户提交的返利数据信息导出为excel表的形式，所以对此功能进行了简单的总结：</p>
<h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要是两个依赖:(xlsx 和 file-saver)</span><br><span class="line">npm install --save xlsx file-saver</span><br></pre></td></tr></table></figure>
<p>对于这两个插件使用，github上边有更加详细的参考<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/SheetJS/js-xlsx](https://github.com/SheetJS/js-xlsx)</span><br><span class="line">https://github.com/eligrey/FileSaver.js](https://github.com/eligrey/FileSaver.js</span><br></pre></td></tr></table></figure></p>
<h2 id="在组件头里边引入插件-测试的时候，下边代码放到入口js文件main-js的时候没有效果，遗留问题，有待解决-（放到组件头里边能够实现效果）"><a href="#在组件头里边引入插件-测试的时候，下边代码放到入口js文件main-js的时候没有效果，遗留问题，有待解决-（放到组件头里边能够实现效果）" class="headerlink" title="在组件头里边引入插件(测试的时候，下边代码放到入口js文件main.js的时候没有效果，遗留问题，有待解决)（放到组件头里边能够实现效果）"></a>在组件头里边引入插件(测试的时候，下边代码放到入口js文件main.js的时候没有效果，遗留问题，有待解决)（放到组件头里边能够实现效果）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import FileSaver from <span class="string">'file-saver'</span></span><br><span class="line">import XLSX from <span class="string">'xlsx'</span></span><br></pre></td></tr></table></figure>
<h2 id="在对应组件里边methods里边写一个方法（到处的时候进行调用）"><a href="#在对应组件里边methods里边写一个方法（到处的时候进行调用）" class="headerlink" title="在对应组件里边methods里边写一个方法（到处的时候进行调用）"></a>在对应组件里边methods里边写一个方法（到处的时候进行调用）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">exportExcel</span></span> () &#123;</span><br><span class="line">    /* generate workbook object from table */</span><br><span class="line">    <span class="built_in">let</span> wb = XLSX.utils.table_to_book(document.querySelector(<span class="string">'#rebateSetTable'</span>));</span><br><span class="line">    /* get binary string as output */</span><br><span class="line">    <span class="built_in">let</span> wbout = XLSX.write(wb, &#123; bookType: <span class="string">'xlsx'</span>, bookSST: <span class="literal">true</span>, <span class="built_in">type</span>: <span class="string">'array'</span> &#125;);</span><br><span class="line">    try &#123;</span><br><span class="line">        FileSaver.saveAs(new Blob([wbout], &#123; <span class="built_in">type</span>: <span class="string">'application/octet-stream'</span> &#125;), <span class="string">'用户提交返利表.xlsx'</span>);</span><br><span class="line">    &#125; catch (e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof console !== <span class="string">'undefined'</span>)</span><br><span class="line">            console.log(e, wbout)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> wbout</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p>提示：<br>上边方法中：XLSX.uitls.table_to_book( 放入的是table 的DOM 节点 ) ，sheetjs.xlsx 即为导出表格的名字，可修改！</p>
<h2 id="点击导出按钮执行-exportExcel-的方法即可-。"><a href="#点击导出按钮执行-exportExcel-的方法即可-。" class="headerlink" title="点击导出按钮执行 exportExcel 的方法即可 。"></a>点击导出按钮执行 exportExcel 的方法即可 。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"export"</span>&gt;</span><br><span class="line">     &lt;el-button @click=<span class="string">"exportExcel"</span> style=<span class="string">"margin-top: 2px;"</span> size=<span class="string">"medium"</span> <span class="built_in">type</span>=<span class="string">"success"</span>&gt;导出&lt;/el-button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
                
                <div class="readmore">
                    <a href="/2019/07/13/vue/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/13/ArcGIS/">
                        ArcGIS
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-07-13T13:35:13.000Z">
                            2019-07-13
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/ArcGIS/">ArcGIS</a></li></ul>
                </div>
                
                    
                
                <div class="readmore">
                    <a href="/2019/07/13/ArcGIS/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/13/react/">
                        React
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-07-13T13:35:13.000Z">
                            2019-07-13
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/React/">React</a></li></ul>
                </div>
                
                    <p># </p>

                
                <div class="readmore">
                    <a href="/2019/07/13/react/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/04/git/">
                        git
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-07-04T14:24:57.000Z">
                            2019-07-04
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/git/">git</a></li></ul>
                </div>
                
                    <h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><blockquote>
<p>初始化一个Git仓库，使用git init命令。</p>
</blockquote>
<blockquote>
<p>添加文件到Git仓库，分两步：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；</span><br><span class="line">使用命令git commit -m &lt;message&gt;，完成。</span><br></pre></td></tr></table></figure>
<h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><blockquote>
<p>首先需要理解工作区和版本库的概念：</p>
</blockquote>
<p>工作区（Working Directory）：就是可以在电脑上看到的目录，比如目录文件夹，就是一个工作区；<br>版本库（Repository）: 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>git的版本库中存放很多的东西，其中最重要的就是stage(index)的暂存区，还有git为我们创建的第一个分支master，以及指向maste分支的一个HEAD指针。<br><img src="/2019/07/04/git/01.png" alt="01.png"></p>
<blockquote>
<p>将文件提交到版本库中需要两个步骤(也可以说是三个步骤)：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status  可以查看哪些文件在本次修改了，以便我们清楚在下一步应该提交哪些文件</span><br><span class="line">git add &lt;filePath&gt;   此命令是将file文件提交到暂存区，此命令是单个文件提交，也可以用</span><br><span class="line">git add . 将工作区所有文件都提交，但一般没有这个必要，只需要将本次修改提交就好；</span><br><span class="line">git commit -m<span class="string">'提交描述'</span>    次命令是将暂存区的所有文件提交到版本库中的当前分支上，一般提交在后面加上本次修改的描述。</span><br></pre></td></tr></table></figure>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>总结：</p>
<blockquote>
<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。<br>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。<br>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、git <span class="built_in">log</span>命令显示从最近到最远的提交日志</span><br><span class="line">2、如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">看到的一大串类似1094adb...的是commit id（版本号）</span><br><span class="line">3、要把当前版本回退到上一个版本，就可以使用git reset命令：$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。<br>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。<br>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</file></p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>1、要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p>
<p>2、关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p>
<p>3、此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，方便！</p>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>若我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。<br>1、首先，登陆GitHub，创建一个新的仓库。<br>2、勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件。<br>3、用命令git clone克隆一个本地库。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>总结：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure></p>
<p>1、创建dev分支，然后切换到dev分支：$ git checkout -b dev<br>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<br>$ git branch dev<br>$ git checkout dev</p>
<p>2、用git branch命令查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号：$ git branch<br>3、我们就可以在dev分支上正常提交<br>4、dev分支的工作完成，我们就可以切换回master分支：git checkout master<br>5、我们把dev分支的工作成果合并到master分支上：git merge dev<br>git merge命令用于合并指定分支到当前分支<br>6、合并完成后，就可以放心地删除dev分支了：git branch -d dev<br>7、删除后，查看branch，就只剩下master分支了</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用git log –graph命令可以看到分支合并图。</p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><blockquote>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
</blockquote>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D 【name】强行删除。</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>多人协作的工作模式通常是这样：</p>
<p>1、首先，可以试图用git push origin 【branch-name】推送自己的修改；</p>
<p>2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
<p>3、如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>4、没有冲突或者解决掉冲突后，再用git push origin 【branch-name】推送就能成功！</p>
<p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to 【branch-name】 origin/【branch-name】。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>
<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>命令git tag 【tagname】用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>
<p>命令git tag -a 【tagname】 -m “blablabla…”可以指定标签信息；</p>
<p>命令git tag可以查看所有标签</p>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>命令git push origin 【tagname】可以推送一个本地标签；</p>
<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>
<p>命令git tag -d 【tagname】可以删除一个本地标签；</p>
<p>命令git push origin :refs/tags/【tagname】可以删除一个远程标签。</p>
<h2 id="git命令汇总"><a href="#git命令汇总" class="headerlink" title="git命令汇总"></a>git命令汇总</h2><p><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">Git Cheat Sheet</a></p>

                
                <div class="readmore">
                    <a href="/2019/07/04/git/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/07/03/前端工作流/">
                        前端工作流搭建
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-07-03T14:24:57.000Z">
                            2019-07-03
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/其他前端技术/">其他前端技术</a></li></ul>
                </div>
                
                    <h1 id="1-工作流创建"><a href="#1-工作流创建" class="headerlink" title="1. 工作流创建"></a>1. 工作流创建</h1><h2 id="github申请注册"><a href="#github申请注册" class="headerlink" title="github申请注册"></a>github申请注册</h2><h2 id="建立ZJHBT仓库"><a href="#建立ZJHBT仓库" class="headerlink" title="建立ZJHBT仓库"></a>建立ZJHBT仓库</h2><p> 若仓库类型为Private,可以在setting —&gt; Collaborator给其他人开启自己版本库的权限。（最多3个，否则需包月）</p>
<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p> 安装java 环境，下载对应版本，这里下载jdk-8u211-windows-x64.exe，须有Orale账户<br> 本项目Jenkins账户，访问网址http:xx.xx.xx（默认端口8080，可修改）</p>
<h3 id="Jenkins与git配置"><a href="#Jenkins与git配置" class="headerlink" title="Jenkins与git配置"></a>Jenkins与git配置</h3><p>参考：<a href="https://juejin.im/post/5ad1980e6fb9a028c42ea1be" target="_blank" rel="noopener">https://juejin.im/post/5ad1980e6fb9a028c42ea1be</a></p>

                
                <div class="readmore">
                    <a href="/2019/07/03/前端工作流/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/02/15/tcp/">
                        tcp
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-02-15T01:40:54.000Z">
                            2019-02-15
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <blockquote>
<p>参考：<a href="https://juejin.im/post/5a7ef7ce5188257a856f38b0" target="_blank" rel="noopener">https://juejin.im/post/5a7ef7ce5188257a856f38b0</a></p>
</blockquote>
<h2 id="TCP三次握手与四次挥手解释1"><a href="#TCP三次握手与四次挥手解释1" class="headerlink" title="TCP三次握手与四次挥手解释1"></a>TCP三次握手与四次挥手解释1</h2><p>首先来看看OSI的七层模型：<br><img src="/2019/02/15/tcp/OSI.jpg" alt="OSI.jpg"><br>我们需要知道TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层；在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下：<br><img src="/2019/02/15/tcp/OSI01.jpg" alt="OSI01.jpg"><br>TCP是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记TCP协议中每个字段的含义。哦，来吧。</p>
<p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的TCP三次握手。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。<br><img src="/2019/02/15/tcp/tcp03.jpg" alt="tcp03.jpg"></p>
<h3 id="握手说明"><a href="#握手说明" class="headerlink" title="握手说明"></a>握手说明</h3><ul>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li>
<li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。<br>那四次分手呢？</li>
</ul>
<h3 id="挥手说明"><a href="#挥手说明" class="headerlink" title="挥手说明"></a>挥手说明</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
<ul>
<li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>-第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li>
<li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li>
<li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>
</ul>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h3><p>既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>在书中同时举了一个例子，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</span><br></pre></td></tr></table></figure></p>
<p>这就很明白了，防止了服务器端的一直等待而浪费资源。</p>
<h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手?"></a>为什么要四次挥手?</h3><p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<ul>
<li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li>
<li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li>
<li>CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</li>
<li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li>
<li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li>
<li>CLOSED: 表示连接中断。</li>
</ul>
<h2 id="TCP三次握手与四次挥手解释2"><a href="#TCP三次握手与四次挥手解释2" class="headerlink" title="TCP三次握手与四次挥手解释2"></a>TCP三次握手与四次挥手解释2</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="/2019/02/15/tcp/tcp01.jpg" alt="tcp01.jpg"></p>
<blockquote>
<p>PS：TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。</p>
</blockquote>
<p>起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。<br>服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p>
<h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。</p>
<ul>
<li>PS1：SYN=1，ACK=0表示该报文段为连接请求报文。</li>
<li>PS2：x为本次TCP通信的字节流的初始序号。 TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。</li>
</ul>
<h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。<br>该应答发送完成后便进入SYN-RCVD状态。</p>
<ul>
<li>PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。</li>
<li>PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。</li>
<li>PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。</li>
</ul>
<h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。<br>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。<br>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！<br>为什么连接建立需要三次握手，而不是两次握手？<br>防止失效的连接请求报文段被服务端接收，从而产生错误。<br>PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。<br>若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><img src="/2019/02/15/tcp/tcp02.jpg" alt="tcp02.jpg"><br>TCP连接的释放一共需要四步，因此称为『四次挥手』。<br>我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。</p>
<h4 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h4><p>若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：<br>FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。</p>
<ul>
<li>PS1：FIN=1表示该报文段是一个连接释放请求。</li>
<li>PS2：seq=u，u-1是A向B发送的最后一个字节的序号。</li>
</ul>
<h4 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h4><p>B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：<br>ACK=1，seq=v，ack=u+1。</p>
<ul>
<li>PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。</li>
<li>PS2：seq=v，v-1是B向A发送的最后一个字节的序号。</li>
<li>PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。</li>
</ul>
<p>A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。<br>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</p>
<h4 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h4><p>当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</p>
<h4 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h4><p>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</p>
<p>为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？ 为了保证B能收到A的确认应答。 若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。</p>

                
                <div class="readmore">
                    <a href="/2019/02/15/tcp/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/07/类class/">
                        类class
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-07T07:48:34.000Z">
                            2019-01-07
                        </time>
                    
                    
                </div>
                
                    
                
                <div class="readmore">
                    <a href="/2019/01/07/类class/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/07/Promise/">
                        Promise
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-07T02:25:07.000Z">
                            2019-01-07
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <blockquote>
<p>参考:<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a></p>
<ul>
<li>Promise.prototype.then()</li>
<li>Promise.prototype.catch()</li>
<li>Promise.prototype.finally()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
<li>Promise.resolve()</li>
<li>Promise.reject()</li>
<li>Promise.try()</li>
</ul>
</blockquote>
<p>这里仅讨论.then()</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<p>首先，Promise 是一个对象，也是一个构造函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f1(resolve, reject) &#123;</span><br><span class="line">  // 异步代码</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Promise(f1)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Promise构造函数接受一个回调函数f1作为参数，f1里面是异步操作的代码。然后，返回的p1就是一个 Promise 实例。</p>
<p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(f1);</span><br><span class="line">p1.then(f2);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，f1的异步操作执行完成，就会执行f2。</p>
<p>传统的写法可能需要把f2作为回调函数传入f1，比如写成f1(f2)，异步操作完成后，在f1内部调用f2。Promise 使得f1和f2变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">step1(<span class="keyword">function</span> (value1) &#123;</span><br><span class="line">  step2(value1, <span class="keyword">function</span>(value2) &#123;</span><br><span class="line">    step3(value2, <span class="keyword">function</span>(value3) &#123;</span><br><span class="line">      step4(value3, <span class="keyword">function</span>(value4) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Promise 的写法</span><br><span class="line">(new Promise(step1))</span><br><span class="line">  .<span class="keyword">then</span>(step2)</span><br><span class="line">  .<span class="keyword">then</span>(step3)</span><br><span class="line">  .<span class="keyword">then</span>(step4);</span><br></pre></td></tr></table></figure></p>
<p>从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的Promise实例的生成格式，做了简化，真正的语法请参照下文。</p>
<p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p>
<p>Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。</p>
<h1 id="Promise-对象的状态"><a href="#Promise-对象的状态" class="headerlink" title="Promise 对象的状态"></a>Promise 对象的状态</h1><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<blockquote>
<blockquote>
<p>》异步操作未完成（pending）<br>》异步操作成功（fulfilled）<br>》异步操作失败（rejected）</p>
</blockquote>
</blockquote>
<p>上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。</p>
<p>这三种的状态的变化途径只有两种。</p>
<blockquote>
<p>》从“未完成”到“成功”<br>》从“未完成”到“失败”</p>
</blockquote>
<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p>
<p>因此，Promise 的最终结果只有两种。</p>
<blockquote>
<p>》异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。<br>》异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected</p>
</blockquote>
<h1 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h1><p>JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; /* 异步操作失败 */</span><br><span class="line">    reject(new Error());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>
<p>resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>下面是一个例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).<span class="keyword">then</span>(<span class="keyword">function</span>(val)&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;)</span><br><span class="line">或</span><br><span class="line">timeout(100).<span class="keyword">then</span>((val)=&gt;&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，timeout(100)返回一个Promise实例。100毫秒以后，该实例的状态会变为fulfilled</p>
<h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>Promise 实例的then方法，用来添加回调函数。</p>
<p>then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(<span class="string">'成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(console.log, console.error);</span><br><span class="line">// <span class="string">"成功"</span></span><br><span class="line"></span><br><span class="line">var p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  reject(new Error(<span class="string">'失败'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(console.log, console.error);</span><br><span class="line">// Error: 失败</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p1和p2都是Promise 实例，它们的then方法绑定两个回调函数：成功时的回调函数console.log，失败时的回调函数console.error（可以省略）。p1的状态变为成功，p2的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。</p>
<p>then方法可以链式使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br><span class="line">  .<span class="keyword">then</span>(step1)</span><br><span class="line">  .<span class="keyword">then</span>(step2)</span><br><span class="line">  .<span class="keyword">then</span>(step3)</span><br><span class="line">  .<span class="keyword">then</span>(</span><br><span class="line">    console.log,</span><br><span class="line">    console.error</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。</p>
<p>最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise 开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。</p>
<h1 id="then-用法辨析"><a href="#then-用法辨析" class="headerlink" title="then() 用法辨析"></a>then() 用法辨析</h1><p>Promise 的用法，简单说就是一句话：使用then方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">f1().<span class="keyword">then</span>(f2());</span><br><span class="line"></span><br><span class="line">// 写法四</span><br><span class="line">f1().<span class="keyword">then</span>(f2);</span><br></pre></td></tr></table></figure></p>
<p>为了便于讲解，下面这四种写法都再用then方法接一个回调函数f3。写法一的f3回调函数的参数，是f2函数的运行结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> f2();</span><br><span class="line">&#125;).<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法二的f3回调函数的参数是undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  f2();</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法三的f3回调函数的参数，是f2函数返回的函数的运行结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(f2())</span><br><span class="line">  .<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法四与写法一只有一个差别，那就是f2会接收到f1()返回的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(f2)</span><br><span class="line">  .<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p>
<p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>
<p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p>
<h1 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h1><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">&#125;).<span class="keyword">then</span>(console.log);</span><br><span class="line"></span><br><span class="line">console.log(2);</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码会先输出2，再输出1。因为console.log(2)是同步任务，而then的回调函数属于异步任务，一定晚于同步任务执行。</p>
<p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(2);</span><br><span class="line">&#125;).<span class="keyword">then</span>(console.log);</span><br><span class="line"></span><br><span class="line">console.log(3);</span><br><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。</p>

                
                <div class="readmore">
                    <a href="/2019/01/07/Promise/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/05/垂直居中/">
                        垂直居中
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-05T01:25:40.000Z">
                            2019-01-05
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="16种方法实现水平居中垂直居中"><a href="#16种方法实现水平居中垂直居中" class="headerlink" title="16种方法实现水平居中垂直居中"></a>16种方法实现水平居中垂直居中</h1><p>熟悉水平居中和垂直居中的方法, 不为别的, 就为用的时候能够信手拈来. 下面直接步入正题.<br>原文：16种方法实现水平居中垂直居中</p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>1) 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中.</p>
<p>2) 若是块级元素, 该元素设置 margin:0 auto即可.</p>
<p>3) 若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    width: -moz-fit-content;</span><br><span class="line">    width: -webkit-fit-content;</span><br><span class="line">    width:fit-content;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器.</p>
<p>4) 使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下:</p>
<p>.son{<br>    display: flex;<br>    justify-content: center;<br>}复制代码<br>5) 使用flex 2009年版本, 父元素display: box;box-pack: center;如下设置:</p>
<p>.parent {<br>    display: -webkit-box;<br>    -webkit-box-orient: horizontal;<br>    -webkit-box-pack: center;<br>    display: -moz-box;<br>    -moz-box-orient: horizontal;<br>    -moz-box-pack: center;<br>    display: -o-box;<br>      -o-box-orient: horizontal;<br>      -o-box-pack: center;<br>      display: -ms-box;<br>      -ms-box-orient: horizontal;<br>      -ms-box-pack: center;<br>      display: box;<br>      box-orient: horizontal;<br>      box-pack: center;<br>}复制代码<br>6) 使用CSS3中新增的transform属性, 子元素设置如下:</p>
<p>.son{<br>    position:absolute;<br>      left:50%;<br>      transform:translate(-50%,0);<br>}复制代码<br>7) 使用绝对定位方式, 以及负值的margin-left, 子元素设置如下:</p>
<p>.son{<br>    position:absolute;<br>    width:固定;<br>    left:50%;<br>    margin-left:-0.5宽度;<br>}复制代码<br>8) 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下:</p>
<p>.son{<br>    position:absolute;<br>    width:固定;<br>    left:0;<br>    right:0;<br>    margin:0 auto;<br>}复制代码</p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><p>1) 若元素是单行文本, 则可设置 line-height 等于父元素高度</p>
<h3 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h3><p>2) 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央.</p>
<p>.parent::after, .son{<br>    display:inline-block;<br>    vertical-align:middle;<br>}<br>.parent::after{<br>    content:’’;<br>    height:100%;<br>}复制代码<br>这是一种很流行的方法, 也适应IE7.</p>
<h3 id="元素高度不定"><a href="#元素高度不定" class="headerlink" title="元素高度不定"></a>元素高度不定</h3><p>3) 可用 vertical-align 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle;</p>
<p>优点</p>
<p>元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断.</p>
<p>缺点</p>
<p>IE6~7, 甚至IE8 beta中无效.</p>
<p>4) 可用 Flex 2012版, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《弹性盒模型Flex指南》</p>
<p>父元素做如下设置即可保证子元素垂直居中:</p>
<p>.parent {<br>  display: flex;<br>  align-items: center;<br>}复制代码<br>优点</p>
<p>内容块的宽高任意, 优雅的溢出.<br>可用于更复杂高级的布局技术中.<br>缺点</p>
<p>IE8/IE9不支持<br>需要浏览器厂商前缀<br>渲染上可能会有一些问题<br>5) 使用flex 2009版.</p>
<p>.parent {<br>      display: box;<br>      box-orient: vertical;<br>      box-pack: center;<br>}复制代码<br>优点</p>
<p>实现简单, 扩展性强</p>
<p>缺点</p>
<p>兼容性差, 不支持IE</p>
<p>6) 可用 transform , 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<p>.son{<br>    position:absolute;<br>    top:50%;<br>    -webkit-transform: translate(-50%,-50%);<br>    -ms-transform: translate(-50%,-50%);<br>    transform: translate(-50%,-50%);<br>}复制代码<br>优点</p>
<p>代码量少</p>
<p>缺点</p>
<p>IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象.</p>
<p>元素高度固定<br>7) 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<p>.son{<br>    position:absolute;<br>    top:50%;<br>    height:固定;<br>    margin-top:-0.5高度;<br>}复制代码<br>优点</p>
<p>适用于所有浏览器.</p>
<p>缺点</p>
<p>父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条.</p>
<p>8) 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<p>.son{<br>    position:absolute;<br>    height:固定;<br>    top:0;<br>    bottom:0;<br>    margin:auto 0;<br>}复制代码<br>优点</p>
<p>简单</p>
<p>缺点</p>
<p>没有足够空间时, 子元素会被截断, 但不会有滚动条.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>水平居中较为简单, 共提供了8种方法, 一般情况下 text-align:center,marin:0 auto; 足矣</p>
<p>① text-align:center;<br>② margin:0 auto;<br>③ width:fit-content;<br>④ flex<br>⑤ 盒模型<br>⑥ transform<br>⑦ ⑧ 两种不同的绝对定位方法<br>垂直居中, 共提供了8种方法.</p>
<p>① 单行文本, line-height<br>② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现<br>③ vertical-align<br>④ flex<br>⑤ 盒模型<br>⑥ transform<br>⑦ ⑧ 两种不同的绝对定位方法<br>我们发现, flex, 盒模型, transform, 绝对定位, 这几种方法同时适用于水平居中和垂直居中.</p>
<h1 id="水平垂直居中实现"><a href="#水平垂直居中实现" class="headerlink" title="水平垂直居中实现"></a>水平垂直居中实现</h1><h2 id="仅居中元素定宽高适用："><a href="#仅居中元素定宽高适用：" class="headerlink" title="仅居中元素定宽高适用："></a>仅居中元素定宽高适用：</h2><ul>
<li><a href="http://yanhaijing.com/vertical-center/absolute1.html" target="_blank" rel="noopener">absolute + 负margin</a></li>
<li><a href="http://yanhaijing.com/vertical-center/absolute2.html" target="_blank" rel="noopener">absolute + margin auto</a></li>
<li><a href="http://yanhaijing.com/vertical-center/absolute3.html" target="_blank" rel="noopener">absolute + calc</a></li>
</ul>
<h2 id="居中元素不定宽高适用："><a href="#居中元素不定宽高适用：" class="headerlink" title="居中元素不定宽高适用："></a>居中元素不定宽高适用：</h2><ul>
<li><a href="http://yanhaijing.com/vertical-center/absolute4.html" target="_blank" rel="noopener">absolute + transform</a></li>
<li><a href="http://yanhaijing.com/vertical-center/writing-mode.html" target="_blank" rel="noopener">writing-mode</a></li>
<li><a href="http://yanhaijing.com/vertical-center/lineheight.html" target="_blank" rel="noopener">lineheight</a></li>
<li><a href="http://yanhaijing.com/vertical-center/table.html" target="_blank" rel="noopener">table</a></li>
<li><a href="http://yanhaijing.com/vertical-center/css-table.html" target="_blank" rel="noopener">css-table</a></li>
<li><a href="http://yanhaijing.com/vertical-center/flex.html" target="_blank" rel="noopener">flex</a></li>
<li><a href="http://yanhaijing.com/vertical-center/grid.html" target="_blank" rel="noopener">grid</a></li>
</ul>
<h2 id="absolute-负margin"><a href="#absolute-负margin" class="headerlink" title="absolute + 负margin"></a>absolute + 负margin</h2><p>为了实现上面的效果先来做些准备工作，假设HTML代码如下，总共两个元素，父元素和子元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>wp是父元素的类名，box是子元素的类名，因为有定宽和不定宽的区别，size用来表示指定宽度，下面是所有效果都要用到的公共代码，主要是设置颜色和宽高<br>注意：后面不在重复这段公共代码，只会给出相应提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 公共代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    background: green;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box.size&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">/* 公共代码 */</span><br></pre></td></tr></table></figure></p>
<p>绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的居中显示，但绝对定位是基于子元素的左上角，期望的效果是子元素的中心居中显示为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了，css代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">    margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是我比较常用的方式，这种方式比较好理解，兼容性也很好，缺点是<font color="red">需要知道子元素的宽高</font></p>
<h2 id="absolute-margin-auto"><a href="#absolute-margin-auto" class="headerlink" title="absolute + margin auto"></a>absolute + margin auto</h2><p>这种方式也要求居中元素的宽高必须固定，HTML代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法兼容性也很好，缺点是需要知道子元素的宽高</p>
<h2 id="absolute-calc"><a href="#absolute-calc" class="headerlink" title="absolute + calc"></a>absolute + calc</h2><p>这种方式也要求居中元素的宽高必须固定，所以我们为box增加size类，HTML代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>感谢css3带来了计算属性，既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;;</span><br><span class="line">    top: calc(50% - 50px);</span><br><span class="line">    left: calc(50% - 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法兼容性依赖calc的兼容性，缺点是需要知道子元素的宽高</p>
<h2 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h2><p>还是绝对定位，但这个方法不需要子元素固定宽高，所以不再需要size类了，HTML代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>修复绝对定位的问题，还可以使用css3新增的transform，transform的translate属性也可以设置百分比，其是相对于自身的宽和高，所以可以讲translate设置为-50%，就可以做到居中了，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法兼容性依赖translate2d的兼容性</p>
<h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h2><p>利用行内元素居中属性也可以做到水平垂直居中，HTML代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>把box设置为行内元素，通过text-align就可以做到水平居中，但很多同学可能不知道通过通过vertical-align也可以在垂直方向做到居中，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    line-height: 300px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: 0px;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    line-height: initial;</span><br><span class="line">    text-align: left; /* 修正文字 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法需要在子元素中将文字显示重置为想要的效果</p>
<h2 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h2><p>writing-mode可以改变文字的显示方向，比如可以通过writing-mode让文字的显示变为垂直方向<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;div1&quot;&gt;水平方向&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div2&quot;&gt;垂直方向&lt;/div&gt;</span><br><span class="line">.div2 &#123;</span><br><span class="line">    writing-mode: vertical-lr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">水平方向</span><br><span class="line">垂</span><br><span class="line">直</span><br><span class="line">方</span><br><span class="line">向</span><br></pre></td></tr></table></figure></p>
<p>更神奇的是所有水平方向上的css属性，都会变为垂直方向上的属性，比如text-align，通过writing-mode和text-align就可以做到水平和垂直方向的居中了，只不过要稍微麻烦一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;wp-inner&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">复制代码/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    writing-mode: vertical-lr;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.wp-inner &#123;</span><br><span class="line">    writing-mode: horizontal-tb;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    text-align: center;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin: auto;</span><br><span class="line">    text-align: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法实现起来和理解起来都稍微有些复杂</p>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>曾经table被用来做页面布局，现在没人这么做了，但table也能够实现水平垂直居中，但是会增加很多冗余代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td class=&quot;wp&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>
<p>tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.wp &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法就是代码太冗余，而且也不是table的正确用法</p>
<h2 id="css-table"><a href="#css-table" class="headerlink" title="css-table"></a>css-table</h2><p>css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面通过css属性，可以让div显示的和table一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wp &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    text-align: center;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复制代码这种方法和table一样的原理，但却没有那么多冗余代码，兼容性也还不错</p>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex作为现代的布局方案，颠覆了过去的经验，只需几行代码就可以优雅的做到水平垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.wp &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前在移动端已经完全可以使用flex了，PC端需要看自己业务的兼容性情况</p>
<h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><p>css新出的网格布局，由于兼容性不太好，一直没太关注，通过grid也可以实现水平垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.wp &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    align-self: center;</span><br><span class="line">    justify-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码量也很少，但兼容性不如flex，不推荐使用</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>下面对比下各个方式的优缺点，肯定又双叒叕该有同学说回字的写法了，简单总结下</p>
<ul>
<li>PC端有兼容性要求，宽高固定，推荐absolute + 负margin</li>
<li>PC端有兼容要求，宽高不固定，推荐css-table</li>
<li>PC端无兼容性要求，推荐flex</li>
<li>移动端推荐使用flex</li>
</ul>
<p><strong>小贴士：</strong>关于flex的兼容性决方案，请看这里《<a href="//yanhaijing.com/css/2016/08/21/flex-practice-on-mobile/">移动端flex布局实战</a>》</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>居中元素定宽高固定</th>
<th>PC兼容性</th>
<th>移动端兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td>absolute + 负margin</td>
<td>是</td>
<td>ie6+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>absolute + margin auto</td>
<td>是</td>
<td>ie6+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>absolute + calc</td>
<td>是</td>
<td>ie9+, chrome19+, firefox4+</td>
<td>安卓4.4+, iOS6+</td>
</tr>
<tr>
<td>absolute + transform</td>
<td>否</td>
<td>ie9+, chrome4+, firefox3.5+</td>
<td>安卓3+, iOS6+</td>
</tr>
<tr>
<td>writing-mode</td>
<td>否</td>
<td>ie6+, chrome4+, firefox3.5+</td>
<td>安卓2.3+, iOS5.1+</td>
</tr>
<tr>
<td>lineheight</td>
<td>否</td>
<td>ie6+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>table</td>
<td>否</td>
<td>ie6+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>css-table</td>
<td>否</td>
<td>ie8+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>flex</td>
<td>否</td>
<td>ie10+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>grid</td>
<td>否</td>
<td>ie10+, chrome57+, firefox52+</td>
<td>安卓6+, iOS10.3+</td>
</tr>
</tbody>
</table>

                
                <div class="readmore">
                    <a href="/2019/01/05/垂直居中/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/04/盒模型/">
                        盒模型
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-04T08:40:34.000Z">
                            2019-01-04
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h1><p>简介：就是用来装页面上的元素的矩形区域。CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。</p>
<p>box-sizing(有3个值哦)：border-box,padding-box,content-box.</p>
<p>标准盒子模型：<br><img src="/2019/01/04/盒模型/box1.png" alt=""><br>IE盒子模型：<br><img src="/2019/01/04/盒模型/box2.png" alt=""><br>区别：从图中我们可以看出，这两种盒子模型最主要的区别就是width的包含范围，在标准的盒子模型中，width指content部分的宽度，在IE盒子模型中，width表示content+padding+border这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：</p>
<p>标准盒子模型的盒子宽度：左右border+左右padding+width<br>IE盒子模型的盒子宽度：width</p>
<p>在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型</p>
<p>最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右padding+width</p>

                
                <div class="readmore">
                    <a href="/2019/01/04/盒模型/">
                        阅读更多
                    </a>
                </div>
            </div>
        
    </div>


    <div id="content-aside">
    <div class="content-aside-owner">
        <div id="owner">
    <div class="avatar-bg">
        <div class="index-page">
            <div class="banner">
                <div class="slide slide1">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_left">
                            <div id="canvas_left"></div>
                        </div>
                    </div>
                </div>
                <div class="slide slide2">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_right">
                            <div id="canvas_right"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a href="/"><img class="avatar" src="/images/avatar.jpg" alt=""></a>
    <a href="/"><h3 class="author">解丹丹</h3></a>
    <h4>learning</h4>
    <div class="social">
        
            
              <a href="https://github.com/xdd7130" title="github" class="fa fa-github" target="_blank"></a>
            
        
            
              <a href="#" title="weibo" class="fa fa-weibo" target="_blank"></a>
            
        
    </div>
</div>
    </div>
    
        <div class="content-aside-about">
            <h2>
                <a href="/about">关于</a>
            </h2>
        </div>
    
    <div class="content-aside-tags">
        <h2>
            <a href="/tags">
                标签
                <sup style="font-size: 12px">
                    [24]
                </sup>
            </a>
        </h2>
    </div>
    
<aside id="categories">
    <h2>分类</h2>
    
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ArcGIS/">ArcGIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VUE/">VUE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他前端技术/">其他前端技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
    
</aside>

    
<aside id="acchives">
    <h2>归档</h2>
    
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    
</aside>

</div>

</div>
<nav id="pagination" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
</nav>

    </div>
</div>
<footer id="footer">
     <div id="copyright">&copy; 解丹丹  2019</div>
     
             <!-- 不蒜子统计 -->
             <span id="busuanzi_container_site_pv">
                     本站总访问量<span id="busuanzi_value_site_pv" style="color:#17a167"></span>次
             </span>
             <span class="post-meta-divider">|</span>
             <span id="busuanzi_container_site_uv">
                     本站访客数<span id="busuanzi_value_site_uv" style="color:#17a167"></span>人
             </span>
             <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
       
    <div id="theme">
        Powered by <a href="http://hexo.io">Hexo</a>. Theme by <a href="https://github.com/markyong/hexo-theme-stage">Stage</a>
    </div>
</footer>
<script src="/lib/js/waterrippleeffect.min.js"></script>
<script src="/js/header-bg.main.js"></script>

    <script src="/lib/js/cav.js"></script>
    <script src="/js/avatar-bg.main.js"></script>

</body>
</html>
