
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <title>DD_XIE的学习笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="">
    <meta name="description" content="前端学习">
    
        <link rel="icon" href="/favicon.ico">
    
    
        
            <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
        
            <link rel="stylesheet" href="/css/stage.css">
        
            <link rel="stylesheet" href="/css/avatar-bg.css">
        
    
</head>
</html>
<body>
<header id="header">
    <div class="menu">
        <i class="fa fa-bars"></i>
    </div>
    <div class="header-main">
        <h1><a href="/">DD_XIE的学习笔记</a></h1>
    </div>
    <div id="nav">
        <div class="nav-img" id="nav-img"></div>
        <div class="sentences">
            一切过往，皆为序章；直挂云帆，乘风破浪。
        </div>
    </div>
</header>

<div id="content-outer">
    <div id="content-inner">
        <div class="clearfix">
    
    <div id="recent-posts">
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/02/遍历数组的常用方法/">
                        遍历数组的常用方法
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-02T02:18:07.000Z">
                            2019-01-02
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="遍历数组的常用方法"><a href="#遍历数组的常用方法" class="headerlink" title="遍历数组的常用方法"></a>遍历数组的常用方法</h1><h2 id="最传统方法-for循环"><a href="#最传统方法-for循环" class="headerlink" title="最传统方法 for循环"></a>最传统方法 for循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;,3,5,8];</span><br><span class="line">for(var i = 0; i &lt; arr.length;i++)&#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">    //输出：</span><br><span class="line">     first</span><br><span class="line">     second</span><br><span class="line">     third</span><br><span class="line">     fourth</span><br><span class="line">     3</span><br><span class="line">     5</span><br><span class="line">     8</span><br></pre></td></tr></table></figure>
<h2 id="for…-in"><a href="#for…-in" class="headerlink" title="for… in"></a>for… in</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">for(var i in arr)&#123;</span><br><span class="line">     console.log(arr[i] +&apos;/&apos; + i);</span><br><span class="line"> &#125;</span><br><span class="line"> //输出结果为：</span><br><span class="line">     first/0</span><br><span class="line">     second/1</span><br><span class="line">     third/2</span><br><span class="line">     fourth/3</span><br><span class="line">     3/4</span><br><span class="line">     5/5</span><br><span class="line">     8/6</span><br></pre></td></tr></table></figure>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">for(var item of arr)&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">//输出结果：</span><br><span class="line">    first</span><br><span class="line">    second</span><br><span class="line">    third</span><br><span class="line">    fourth</span><br><span class="line">    3</span><br><span class="line">    5</span><br><span class="line">    8</span><br></pre></td></tr></table></figure>
<p>虽然for… in 、for…of都能够变历数组，但是两者还是有很大区别的，先说结论：</p>
<blockquote>
<p>两者的主要区别在于：</p>
<ul>
<li>他们的迭代方式推荐在循环对象属性的时候，使用for in，在遍历数组的时候推荐使用for of</li>
<li>for…in 循环出来的是key, for…of循环出来的是value</li>
<li>for…in 是ES5 标准，for …of 是ES6标准，兼容性可能存在些问题，请注意使用</li>
<li>for…of 不能遍历普通的对象，需要和Object.keys()搭配使用。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">    //给数组添加新属性</span><br><span class="line">    arr.name = &apos;zhangsan&apos;;</span><br><span class="line">    for(var item of arr)&#123;</span><br><span class="line">        console.log(item);</span><br><span class="line">    &#125;</span><br><span class="line">    //输出：</span><br><span class="line">        first </span><br><span class="line">        second</span><br><span class="line">        third</span><br><span class="line">        fourth</span><br><span class="line">        3</span><br><span class="line">        5</span><br><span class="line">        8</span><br><span class="line">    console.log(&apos;--------------分隔符----------------&apos;);</span><br><span class="line">    for(var item in arr)&#123;</span><br><span class="line">        console.log(arr[item] + &apos;/&apos; + item);</span><br><span class="line">    &#125;</span><br><span class="line">    //输出：</span><br><span class="line">     first/0</span><br><span class="line">     second/1</span><br><span class="line">     third/2</span><br><span class="line">     fourth/3</span><br><span class="line">     3/4</span><br><span class="line">     5/5</span><br><span class="line">     8/6 </span><br><span class="line">     zhangsan/name</span><br></pre></td></tr></table></figure>
<p>循环除了遍历数组元素外，还会遍历自定义属性，for…of只可以循环可迭代的可迭代属性，不可迭代属性在循环中被忽略了</p>
<h2 id="foreach方法"><a href="#foreach方法" class="headerlink" title="foreach方法"></a>foreach方法</h2><p>被传递给foreach的函数会在数组的每个元素上执行一次，元素作为参数传递给该函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;,3,5,8];</span><br><span class="line">//element 表示arr的单元项，index 表示arr单元项对应的索引值</span><br><span class="line">arr.forEach(function(element,index)&#123;</span><br><span class="line">    console.log(element + &apos;/&apos; + index);</span><br><span class="line">&#125;)</span><br><span class="line">//输出结果：</span><br><span class="line">  first/0</span><br><span class="line">  second/1</span><br><span class="line">  third/2</span><br><span class="line">  fourth/3</span><br><span class="line">  3/4</span><br><span class="line">  5/5</span><br><span class="line">  8/6</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：未赋值的值是不会在foreach循环迭代的，但是手动赋值为undefined的元素是会被列出的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;first&quot;,&quot;second&quot;, ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">arr1.forEach(function(element,index)&#123;</span><br><span class="line">    console.log(element + &apos;/&apos; + index);</span><br><span class="line">&#125;)</span><br><span class="line">  //输出结果</span><br><span class="line">     first/0</span><br><span class="line">     second/1</span><br><span class="line">     fourth/3</span><br><span class="line">     3/4</span><br><span class="line">     5/5</span><br><span class="line">     8/6</span><br></pre></td></tr></table></figure>
<h2 id="map遍历数组"><a href="#map遍历数组" class="headerlink" title="map遍历数组"></a>map遍历数组</h2><p>并通过callback对数组元素进行操作，并将所有操作结果放入数组中并返回该数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;];</span><br><span class="line">var arr2 = arr.map(function(item,index,arr)&#123;</span><br><span class="line">   return item.toUpperCase();</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2);</span><br><span class="line">//输出：</span><br><span class="line">[FIRST,SECOND,THIRD, FOURTH]</span><br></pre></td></tr></table></figure></p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter( )"></a>filter( )</h2><p>返回一个包含所有在回调函数上返回为true的元素新数组，回调函数在此担任的是过滤器的角色,当元素符和条件，过滤器就返回true,而filter则会返回所有符合过滤条件的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">    var arr3 = arr.filter(function(item,index,arr)&#123;</span><br><span class="line">        if(typeof item == &apos;number&apos;)&#123;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(arr3);</span><br><span class="line">    //输出结果： </span><br><span class="line">    [3,5,8]</span><br></pre></td></tr></table></figure></p>
<h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><p>当数组中的每一个元素在callback上被返回true时就返回true注意：要求每一个单元项都返回true时才为true)<br>every()与filter()的区别是：后者会返回所有符合过滤条件的元素；前者会判断是不是数组中的所有元素都符合条件，并且返回的是布尔值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">var bol = arr.every(function(item, index, array)&#123;</span><br><span class="line">    if(typeof item == &apos;string&apos;)&#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> console.log(bol); //false</span><br></pre></td></tr></table></figure></p>
<h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><p>只要数组中有一项在callback上就返回true<br>every()与some()的区别是：前者要求所有元素都符合条件才返回true,后者要求只要有符合条件的就返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">    var bol = arr.some(function(item, index, array)&#123;</span><br><span class="line">        if(typeof item == &apos;string&apos;)&#123;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(bol); //true</span><br></pre></td></tr></table></figure></p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class="line"> return previousValue + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>reduce还有第二个参数，我们可以把这个参数作为第一次调用callback时的第一个参数，上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class="line"> return previousValue + currentValue;</span><br><span class="line">&#125;,5);</span><br></pre></td></tr></table></figure></p>
<p>第一次调用的previousValue的值就用传入的第二个参数代替</p>
<h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h2><p>reduceRight()方法的功能和reduce()功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。</p>
<h1 id="数组方法总结"><a href="#数组方法总结" class="headerlink" title="数组方法总结"></a>数组方法总结</h1><p>对于数组，最关心的的两个问题：返回值是什么，会不会对原始数组造成影响，典型的例子就是 splice 和 slice 方法。对于那些返回原数组的函数，我们可以直接调用数组的链式调用，array.filter().sort().reverse()。<br>下面用表格列出来所有方法的功能：<br><img src="/2019/01/02/遍历数组的常用方法/array01.png" alt=""><br>具体可参考：<a href="https://segmentfault.com/a/1190000008147878" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008147878</a></p>

                
                <div class="readmore">
                    <a href="/2019/01/02/遍历数组的常用方法/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/02/理解cookie、session、localStorage、sessionStorage之不同/">
                        理解cookie、session、localStorage、sessionStorage...
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-02T02:03:31.000Z">
                            2019-01-02
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="理解cookie、session、localStorage、sessionStorage之不同"><a href="#理解cookie、session、localStorage、sessionStorage之不同" class="headerlink" title="理解cookie、session、localStorage、sessionStorage之不同"></a>理解cookie、session、localStorage、sessionStorage之不同</h1><p><img src="http12.png" alt=""></p>
<ul>
<li><p>1、相同点：数据都保存在浏览器，同源共享。即相同的域下可以修改读取。</p>
</li>
<li><p>2、不同点：</p>
<p>   <font color="red">大小数量： </font>IE6或更低版本最多20个cookie，IE7+可以有50个。 cookie大小4KB左右，超过部分会被截掉。sessionStoage，localStoage大小可达5M。</p>
<p>   <font color="red">传输： </font>每次请求cookie都会发送到服务器，然后回传给浏览器，sessionStoage,localStoage不会自动发送到服务器端。</p>
<p> <font color="red">有效性：</font>cookie可以设置path路径，限制只属于某个路径。在过期时间之前都有效，即使窗口和浏览器关闭。sesesionStorage当前窗口有效，关闭窗口自动失效。localStorage始终有效，即使窗口和浏览器关闭。</p>
<p> <font color="red">作用域：</font>cookie在同源页面中共享，sessionStorage只能在当前页有效，localStorage在所有同源页面中共享。</p>
<p>  <font color="red">操作方法：</font>Cookie的修改读取方法需自己实现，sessionStorage，localStorage提供了get，set方法。    </p>
</li>
</ul>
<p>注：cookie是不可以或缺的，cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p>
<h1 id="web-Storage支持的属性与方法"><a href="#web-Storage支持的属性与方法" class="headerlink" title="web Storage支持的属性与方法"></a>web Storage支持的属性与方法</h1><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</p>
<p>getItem(key):获取指定key所存储的value值<br>key(index)方法：返回列表中对应索引的key值<br>length属性：返回key/value队列的长度<br>removeItem(key)方法：从Storage中删除一个对应的键值对。<br>setItem(key,value)方法：将value存储到key指定的字段。<br>clear()方法：移除所有的内容</p>

                
                <div class="readmore">
                    <a href="/2019/01/02/理解cookie、session、localStorage、sessionStorage之不同/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/01/跨域/">
                        跨域
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-01T14:00:08.000Z">
                            2019-01-01
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <p>jsonp跨域是通过动态添加script标签实现跨域的由于script标签只能发送get请求所以jsonp不支持post方式的跨域JSONP的最基本的原理是：动态添加一个<script>标签而script标签的src属性是没有跨域的限制的。这样说来，这种跨域方式其实与ajaxXmlHttpRequest协议无关了。可以说jsonp的方式原理上和&lt;scriptsrc=”http://跨域/…xx.js”&gt;</script>是一致的，因为他的原理实际上就是 使用js的script标签 进行传参，那么必然是get方式的了，和浏览器中敲入一个url一样</p>

                
                <div class="readmore">
                    <a href="/2019/01/01/跨域/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2018/12/27/http/">
                        http
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2018-12-27T13:35:13.000Z">
                            2018-12-27
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><ul>
<li><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</p>
</li>
<li><p>200 OK 正常返回信息</p>
</li>
<li><p>201 Created 请求成功并且服务器创建了新的资源</p>
</li>
<li><p>202 Accepted 服务器已接受请求，但尚未处理</p>
</li>
<li><p>301 Moved Permanently 请求的网页已永久移动到新位置。</p>
</li>
<li><p>302 Found 临时性重定向。</p>
</li>
<li><p>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</p>
</li>
<li><p>304 Not Modified 自从上次请求后，请求的网页未修改过。</p>
</li>
<li><p>Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</p>
</li>
<li><p>401 Unauthorized 请求未授权。</p>
</li>
<li><p>403 Forbidden 禁止访问。</p>
</li>
<li><p>404 Not Found 找不到如何与 URI 相匹配的资源。</p>
</li>
<li><p>500 Internal Server Error 最常见的服务器端错误。</p>
</li>
<li><p>503 Service Unavailable 服务器端暂时无法处理请求(可能是过载或维护)。</p>
</li>
</ul>

                
                <div class="readmore">
                    <a href="/2018/12/27/http/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2018/12/27/浏览器缓存/">
                        浏览器缓存
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2018-12-27T13:35:13.000Z">
                            2018-12-27
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="HTTP强缓存和协商缓存"><a href="#HTTP强缓存和协商缓存" class="headerlink" title="HTTP强缓存和协商缓存"></a>HTTP强缓存和协商缓存</h1><blockquote>
<p>浏览器缓存有下面的优点：</p>
<ul>
<li>减少冗余的数据传输</li>
<li>减少服务器负担</li>
<li>加快客户端加载网页的速度</li>
</ul>
</blockquote>
<p>在浏览器第一次发起请求时，本地无缓存，向web服务器发送请求，服务器起端响应请求，浏览器端缓存。过程如下：</p>
<p><center><img src="http01.png" alt=""></center><br>在第一次请求时，服务器会将页面最后修改时间通过Last-Modified标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个Etag，并发送给客户端。<br>浏览器后续再次进行请求时：</p>
<p><center><img src="http02.png" alt=""></center><br>浏览器缓存主要分为强强缓存（也称本地缓存）和协商缓存（也称弱缓存）。根据上图，浏览器在第一次请求发生后，再次发送请求时：</p>
<ul>
<li><p>浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的Cache-Control和Expires来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。后面会讲Cache-Control和Expires相关。</p>
</li>
<li><p>如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过If-None-Match头将先前服务器端发送过来的Etag发送给服务器，服务会对比这个客户端发过来的Etag是否与服务器的相同，若相同，就将If-None-Match的值设为false，返回状态304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将If-None-Match的值设为true，返回状态为200，客户端重新机械服务器端返回的数据；客户端还会通过If-Modified-Since头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。</p>
</li>
</ul>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存是利用http头中的Expires和Cache-Control两个字段来控制的，用来表示资源的缓存时间。强缓存中，普通刷新会忽略它，但不会清除它，需要强制刷新。浏览器强制刷新，请求会带上Cache-Control:no-cache和Pragma:no-cache</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。如我现在这个网页的Expires值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在Expires之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现Cache-Control:max-age和Expires，那么max-age优先级更高。如我主页的response headers部分如下：</p>
<p>cache-control:max-age=691200<br>expires:Fri, 14 Apr 2017 10:47:02 GMT<br>那么表示资源可以被缓存的最长时间为691200秒，会优先考虑max-age。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control是在http1.1中出现的，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：</p>
<p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p>
<p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p>
<p>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</p>
<p>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。<br>Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。</p>
<p>普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。</p>
<p>这个主要涉及到两组header字段：Etag和If-None-Match、Last-Modified和If-Modified-Since。上面以及说得很清楚这两组怎么使用啦~复习一下：</p>
<h3 id="Etag和If-None-Match"><a href="#Etag和If-None-Match" class="headerlink" title="Etag和If-None-Match"></a>Etag和If-None-Match</h3><p>Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。</p>
<p>与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</p>
<h3 id="Last-Modify-If-Modify-Since"><a href="#Last-Modify-If-Modify-Since" class="headerlink" title="Last-Modify/If-Modify-Since"></a>Last-Modify/If-Modify-Since</h3><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>
<p>当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p>
<p>如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。</p>
<p>为什么要有Etag<br>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p>
<p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p>
<p>某些服务器不能精确的得到文件的最后修改时间。</p>
<p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<h1 id="HTTP基于缓存策略三要素分解法"><a href="#HTTP基于缓存策略三要素分解法" class="headerlink" title="HTTP基于缓存策略三要素分解法"></a>HTTP基于缓存策略三要素分解法</h1><h2 id="两道题"><a href="#两道题" class="headerlink" title="两道题"></a>两道题</h2><p>以下为 page.html 内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;page页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><br><span class="line">&lt;img src=&quot;images/head.png&quot; /&gt;</span><br><span class="line">&lt;a href=&quot;page.html&quot;&gt;重新访问page页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>首次访问该页面，页面中 head.png 响应头信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p>
<p>问题1：请问当点击“重新访问 page 页”链接重新加载该页面后， head.png 如何二次加载？<br>问题2：如果将上述信息中的 Cache-Control 设置为 private，那么结果又会如何呢？</p>
<h2 id="HTTP缓存体系"><a href="#HTTP缓存体系" class="headerlink" title="HTTP缓存体系"></a>HTTP缓存体系</h2><p>首先我将 Http 缓存体系分为以下三个部分：<br><img src="http03.png" alt=""></p>
<h3 id="缓存存储策略"><a href="#缓存存储策略" class="headerlink" title="缓存存储策略"></a>缓存存储策略</h3><blockquote>
<p>用来确定 Http响应内容是否可以被客户端缓存，以及可以被哪些客户端缓存这个策略的作用只有一个，用于决定 Http 响应内容是否可缓存到客户端</p>
<ul>
<li>对于 Cache-Control 头里的 Public、Private、no-cache、max-age 、no-store 他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。另关于 no-cache 和 max-age 有点特别，我认为它是一种混合体，下面我会讲到。</li>
</ul>
</blockquote>
<ul>
<li>通过 Cache-Control：Public 设置我们可以将 Http 响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用，为啥？因为它无法确定本地缓存的数据是否可用（可能已经失效），还必须借助一套鉴别机制来确认才行， 这就是我们下面要讲到的“缓存过期策略”。</li>
</ul>
<h3 id="缓存过期策略"><a href="#缓存过期策略" class="headerlink" title="缓存过期策略"></a>缓存过期策略</h3><blockquote>
<p>客户端用来确认存储在本地的缓存数据是否已过期，进而决定是否要发请求到服务端获取数据<br>刚上面我们已经阐述了数据缓存到了本地后还需要经过判断才能使用，那么浏览器通过什么条件来判断呢？ 答案是：Expires，Expires 指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。</p>
</blockquote>
<p>不过 Http 缓存头设计并没有想象的那么规矩，像上面提到的 Cache-Control（这个头是在Http1.1里加进来的）头里的 no-cache 和 max-age 就是特例，它们既包含缓存存储策略也包含缓存过期策略，以 max-age 为例，他实际上相当于：</p>
<p>Cache-Control：public/private（这里不太确定具体哪个）<br>Expires：当前客户端时间 + maxAge 。<br>而 Cache-Control：no-cache 和 Cache-Control：max-age=0 （单位是秒）相当</p>
<p>这里需要注意的是：</p>
<p>Cache-Control 中指定的缓存过期策略优先级高于Expires，当它们同时存在的时候，后者会被覆盖掉。</p>
<p>缓存数据标记为已过期只是告诉客户端不能再直接从本地读取缓存了，需要再发一次请求到服务器去确认，并不等同于本地缓存数据从此就没用了，有些情况下即使过期了还是会被再次用到，具体下面会讲到。</p>
<h3 id="缓存对比策略"><a href="#缓存对比策略" class="headerlink" title="缓存对比策略"></a>缓存对比策略</h3><p>将缓存在客户端的数据标识发往服务端，服务端通过标识来判断客户端 缓存数据是否仍有效，进而决定是否要重发数据。</p>
<p>客户端检测到数据过期或浏览器刷新后，往往会重新发起一个 http 请求到服务器，服务器此时并不急于返回数据，而是看请求头有没有带标识（ If-Modified-Since、If-None-Match）过来，如果判断标识仍然有效，则返回304告诉客户端取本地缓存数据来用即可（这里要注意的是你必须要在首次响应时输出相应的头信息（Last-Modified、ETags）到客户端）。至此我们就明白了上面所说的本地缓存数据即使被认为过期，并不等于数据从此就没用了的道理了。</p>
<p>关于 Last-Modified，这个响应头使用要注意，可能会影响到缓存过期策略，具体原因，后面我会通过解答开篇提到的2道题来作说明。</p>
<p>以上就是我所认识的缓存策略，下面我将缓存策略三要素和常用的几个缓存头（项）结合一起，让大家更清晰的认识到它们之间的关系：<br><img src="http04.png" alt=""><br>通过上图我可以清晰的看到各缓存项分别属于哪个缓存策略范畴，这其中有部分重叠，它表明这些缓存项具有多重缓存策略，所以实际在分析缓存头的时候，除了常规的头外，我们还需要将这些具有双重缓存策略的项分解开来。</p>
<p>最后我们回到最开始提到的2道题目，我们来一起分解下：</p>
<p>第一道题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p>
<p>分析上述 Http 响应头发现有以下两项与缓存相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache </span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br></pre></td></tr></table></figure></p>
<p>我们上面讲到了 Cache-Control: no-cache 相当于 Cache-Control: max-age=0，且他们都是多重策略头，我们需将其分解：</p>
<p>Cache-Control: no-cache 等于 Cache-Control: max-age=0，<br>接着 Cache-Control: max-age=0 又可分解成：</p>
<p>Cache-Control: public/private （不确定是二者中的哪一个）<br>Expires: 当前时间<br>最终我们得到了以下完整的缓存策略三要素：<br><img src="http05.png" alt=""><br>所以最终结果是：浏览器会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比：</p>
<p>a）对比失败：服务器返回200并重发数据，客户端接收到数据后展示，并刷新本地缓存。</p>
<p>b）对比成功：服务器返回304且不重发数据，客户端收到304状态码后从本地读取缓存数据。以下为模拟此种情况下请求后的抓包情况：<br><img src="http06.png" alt=""><br>这道题本身不难，但若认为 no-cache 不会缓存数据到本地，那么你理解起来就会很矛盾，因为如果文件数据没有被本地缓存，服务器返回304后将会无法展示出图片内容，但实际上它是能正常展示的。这道题很好的证明了 no-cache 也会缓存数据到本地这一说法。<br>第二道题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: private</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p>
<p>解题思路和上题一样，首先先找到缓存相关项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private     </span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">这时我们会发现根本找不到缓存过期策略项，那答案会不会和上面一样？ 一时半会也分析不出答案，那只能实际测试下了：</span><br></pre></td></tr></table></figure></p>
<p><img src="http07.png" alt=""><br>再看看 Chrome 浏览器下抓包：<br><img src="http08.png" alt=""><br>可以看到，浏览器后续请求都直接取的本地缓存，看来的确存在某种缓存过期策略（根据我上面的缓存过期策略理论，浏览器如果直接从本地加载缓存数据，说明它相信本地缓存数据有效，那一定存在某种缓存过期判断条件）。这个问题百思不得其解，困扰了我好久，直到一次偶然的机会我在 Fiddler 响应信息面板里的 Caching 选项卡中找到了答案：<br>原来，在没有提供任何浏览器缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略：</p>
<p>根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。</p>
<p>贴一下Caching面板里的描述，英语好的同学可以精准翻译下：<br>最终我们得到了以下完整的缓存策略三要素：<br><img src="http10.png" alt=""><br>最终结果<br>浏览器会根据 Date 和 Last-Modified 之间的时间差值缓存一段时间，这段时间内会直接使用本地缓存数据而不会再去请求服务器（强制请求除外），缓存过期后，会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比并根据服务端的响应状态决定是否要从本地加载缓存数据。</p>
<p>总结<br>Http 缓存设置起来并不复杂，但却容易被轻视， 今天这篇文章结合2道题目，通过分析、解剖相关缓存头，从系统化角度对 Http 缓存机制做了一个较完整的剖析：Http 缓存机制实际上是 Http 缓存策略三个要素（纬度）相互作用的集合，所以在分析和设置 Http 报文缓存头时，只要能从中精准的分解出缓存三要素，我们就能非常准确的预判到缓存设置最终能达到的效果。</p>
<h1 id="浏览器缓存详解-expires-cache-control-last-modified-etag详细说明"><a href="#浏览器缓存详解-expires-cache-control-last-modified-etag详细说明" class="headerlink" title="浏览器缓存详解:expires,cache-control,last-modified,etag详细说明"></a>浏览器缓存详解:expires,cache-control,last-modified,etag详细说明</h1><p><img src="http11.png" alt=""></p>
<h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：</p>
<p>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT</p>
<p>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：</p>
<p>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT</p>
<p>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p>
<p>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求</p>
<h2 id="Etag工作原理"><a href="#Etag工作原理" class="headerlink" title="Etag工作原理"></a>Etag工作原理</h2><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：</p>
<p>Etag:“5d8c72a5edda8d6a:3239″</p>
<p>客户端的查询更新格式是这样的：</p>
<p>If-None-Match:“5d8c72a5edda8d6a:3239″</p>
<p>如果ETag没改变，则返回状态304。</p>
<p>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″</p>
<p>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。</p>
<p>If-None-Match:“5d8c72a5edda8d6a:3239“</p>
<p>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。</p>
<h2 id="Expires-1"><a href="#Expires-1" class="headerlink" title="Expires"></a>Expires</h2><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT</p>
<p>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。</p>
<h2 id="Last-Modified和Expires"><a href="#Last-Modified和Expires" class="headerlink" title="Last-Modified和Expires"></a>Last-Modified和Expires</h2><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。</p>
<h2 id="Etag和Expires"><a href="#Etag和Expires" class="headerlink" title="Etag和Expires"></a>Etag和Expires</h2><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.</p>
<h2 id="Last-Modified和Etag"><a href="#Last-Modified和Etag" class="headerlink" title="Last-Modified和Etag"></a>Last-Modified和Etag</h2><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败</p>
<p>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)</p>
<p>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存</p>
<p>过程如下:</p>
<p>1.客户端请求一个页面（A）。</p>
<p>2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。</p>
<p>3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。</p>
<p>4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。</p>
<p>5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</p>
<p>注：</p>
<p>1、Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。</p>
<p>2、WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；</p>
<p>3、客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；</p>
<p>4、通过上述值到服务器端检查，判断文件是否继续缓存；</p>
<p>7、关于 Cache-Control: max-age=秒 和 Expires</p>
<p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</p>
<p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p>
<p>Expires =max-age +   “每次下载时的当前的request时间”</p>
<p>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 </p>
<h1 id="浏览器缓存总结"><a href="#浏览器缓存总结" class="headerlink" title="浏览器缓存总结"></a>浏览器缓存总结</h1><p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：</p>
<ul>
<li>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li>
<li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li>
<li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；</li>
<li>区别是，强缓存不对发送请求到服务器，但协商缓存会。</li>
<li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li>
<li>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li><p>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p>
<blockquote>
<p>强缓存</p>
</blockquote>
</li>
<li><p>Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）</p>
</li>
<li><p>Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）</p>
<blockquote>
<p>协商缓存</p>
</blockquote>
</li>
<li><p>Last-Modified（值为资源最后更新时间，随服务器response返回）</p>
</li>
<li>If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li>
<li>ETag（表示资源内容的唯一标识，随服务器response返回）</li>
<li>If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li>
</ul>

                
                <div class="readmore">
                    <a href="/2018/12/27/浏览器缓存/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2018/12/26/css./">
                        CSS
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2018-12-26T09:28:15.000Z">
                            2018-12-26
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h2 id="css中font-size为0的妙用-消除内联元素间的间隔"><a href="#css中font-size为0的妙用-消除内联元素间的间隔" class="headerlink" title="css中font-size为0的妙用(消除内联元素间的间隔)"></a>css中font-size为0的妙用(消除内联元素间的间隔)</h2>
                
                <div class="readmore">
                    <a href="/2018/12/26/css./">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2018/12/26/原型/">
                        原型与继承
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2018-12-26T09:28:15.000Z">
                            2018-12-26
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="prototype、proto和constructor的三者关系"><a href="#prototype、proto和constructor的三者关系" class="headerlink" title="prototype、proto和constructor的三者关系"></a>prototype、proto和constructor的三者关系</h1><p>javascript里的关系又多又乱。作用域链是一种单向的链式关系，还算简单清晰；this机制的调用关系，稍微有些复杂；而关于原型，则是prototype、proto和constructor的三角关系。本文先用一张图开宗明义，然后详细解释原型的三角关系<br><img src="/2018/12/26/原型/proto01.png" alt=""></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>上图中的复杂关系，实际上来源就两行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>【构造函数】</li>
</ul>
<p>　　用来初始化新创建的对象的函数是构造函数。在例子中，Foo()函数是构造函数</p>
<ul>
<li>【实例对象】</li>
</ul>
<p>　　通过构造函数的new操作创建的对象是实例对象。可以用一个构造函数，构造多个实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">var f2 = new Foo;</span><br><span class="line">console.log(f1 === f2);//false</span><br></pre></td></tr></table></figure></p>
<ul>
<li>【原型对象及prototype】</li>
</ul>
<p>　　构造函数有一个prototype属性，指向实例对象的原型对象。通过同一个构造函数实例化的多个对象具有相同的原型对象。经常使用原型对象来实现继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">Foo.prototype.a = 1;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">var f2 = new Foo;</span><br><span class="line"></span><br><span class="line">console.log(Foo.prototype.a);//1</span><br><span class="line">console.log(f1.a);//1</span><br><span class="line">console.log(f2.a);//1</span><br></pre></td></tr></table></figure></p>
<ul>
<li>【constructor】</li>
</ul>
<p>　　原型对象有一个constructor属性，指向该原型对象对应的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">console.log(Foo.prototype.constructor === Foo);//true</span><br></pre></td></tr></table></figure></p>
<p>　　由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">console.log(f1.constructor === Foo);//true</span><br></pre></td></tr></table></figure></p>
<ul>
<li>【proto】</li>
</ul>
<p>　　实例对象有一个proto属性，指向该实例对象对应的原型对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">console.log(f1.__proto__ === Foo.prototype);//true</span><br></pre></td></tr></table></figure></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>　　概念介绍完了，现在对图示的关系进行详细说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>【第一部分： Foo】</p>
</blockquote>
<p><img src="/2018/12/26/原型/proto02.png" alt=""><br>实例对象f1是通过构造函数Foo()的new操作创建的。构造函数Foo()的原型对象是Foo.prototype；实例对象f1通过<strong>proto</strong>属性也指向原型对象Foo.prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">console.log(f1.__proto === Foo.prototype);//true</span><br></pre></td></tr></table></figure></p>
<p>　　实例对象f1本身并没有constructor属性，但它可以继承原型对象Foo.prototype的constructor属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">console.log(Foo.prototype.constructor === Foo);//true</span><br><span class="line">console.log(f1.constructor === Foo);//true</span><br><span class="line">console.log(f1.hasOwnProperty(&apos;constructor&apos;));//false</span><br></pre></td></tr></table></figure></p>
<p>　　下图是实例对象f1的控制台效果<br><img src="/2018/12/26/原型/proto03.png" alt=""></p>
<blockquote>
<p>【第二部分： Object】</p>
</blockquote>
<p><img src="/2018/12/26/原型/proto04.png" alt=""><br>　Foo.prototype是f1的原型对象，同时它也是实例对象。实际上，任何对象都可以看做是通过Object()构造函数的new操作实例化的对象<br>　　所以，Foo.prototype作为实例对象，它的构造函数是Object()，原型对象是Object.prototype。相应地，构造函数Object()的prototype属性指向原型对象Object.prototype；实例对象Foo.prototype的proto属性同样指向原型对象Object.prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">console.log(Foo.prototype.__proto__ === Object.prototype);//true</span><br></pre></td></tr></table></figure></p>
<p>　　实例对象Foo.prototype本身具有constructor属性，所以它会覆盖继承自原型对象Object.prototype的constructor属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">console.log(Foo.prototype.constructor === Foo);//true</span><br><span class="line">console.log(Object.prototype.constructor === Object);//true</span><br><span class="line">console.log(Foo.prototype.hasOwnProperty(&apos;constructor&apos;));//true</span><br></pre></td></tr></table></figure></p>
<p>　　下图是实例对象Foo.prototype的控制台效果:<br><img src="/2018/12/26/原型/proto05.png" alt=""><br>如果Object.prototype作为实例对象的话，其原型对象是什么，结果是null。私以为，这可能也是typeof null的结果是’object’的原因之一吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null);//true</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>【第三部分： Function】</p>
</blockquote>
<p><img src="/2018/12/26/原型/proto06.png" alt=""><br>前面已经介绍过，函数也是对象，只不过是具有特殊功能的对象而已。任何函数都可以看做是通过Function()构造函数的new操作实例化的结果</p>
<p>　　如果把函数Foo当成实例对象的话，其构造函数是Function()，其原型对象是Function.prototype；类似地，函数Object的构造函数也是Function()，其原型对象是Function.prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">console.log(Foo.__proto__ === Function.prototype);//true</span><br><span class="line">console.log(Object.__proto__ === Function.prototype);//true</span><br></pre></td></tr></table></figure></p>
<p>　　原型对象Function.prototype的constructor属性指向构造函数Function()；实例对象Object和Foo本身没有constructor属性，需要继承原型对象Function.prototype的constructor属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">var f1 = new Foo;</span><br><span class="line">console.log(Function.prototype.constructor === Function);//true</span><br><span class="line">console.log(Foo.constructor === Function);//true</span><br><span class="line">console.log(Foo.hasOwnProperty(&apos;constructor&apos;));//false</span><br><span class="line">console.log(Object.constructor === Function);//true</span><br><span class="line">console.log(Object.hasOwnProperty(&apos;constructor&apos;));//false</span><br></pre></td></tr></table></figure>
<p>　　所有的函数都可以看成是构造函数Function()的new操作的实例化对象。那么，Function可以看成是调用其自身的new操作的实例化的结果</p>
<p>　　所以，如果Function作为实例对象，其构造函数是Function，其原型对象是Function.prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Function.__proto__ === Function.prototype);//true</span><br><span class="line">console.log(Function.prototype.constructor === Function);//true</span><br><span class="line">console.log(Function.prototype === Function.prototype);//true</span><br></pre></td></tr></table></figure></p>
<p>　　如果Function.prototype作为实例对象的话，其原型对象是什么呢？和前面一样，所有的对象都可以看成是Object()构造函数的new操作的实例化结果。所以，Function.prototype的原型对象是Object.prototype，其原型函数是Object()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Function.prototype.__proto__ === Object.prototype);//true</span><br></pre></td></tr></table></figure></p>
<p>　　第二部分介绍过，Object.prototype的原型对象是null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null);//true</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　【1】函数(Function也是函数)是new Function的结果，所以函数可以作为实例对象，其构造函数是Function()，原型对象是Function.prototype</p>
<p>　　【2】对象(函数也是对象)是new Object的结果，所以对象可以作为实例对象，其构造函数是Object()，原型对象是Object.prototype</p>
<p>　　【3】Object.prototype的原型对象是null</p>
<h1 id="JS继承的6种方式"><a href="#JS继承的6种方式" class="headerlink" title="JS继承的6种方式"></a>JS继承的6种方式</h1><blockquote>
<p>[原型]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// B是A的原型，A是B的构造函数</span><br><span class="line">A.prototype = B</span><br><span class="line">B.constructor = A</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[约定]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Super()&#123;</span><br><span class="line">  this.property = &apos;Super Property&apos;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.getProperty = function()&#123;</span><br><span class="line">  return this.property</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>1.基本思想<br>通过使用call、apply方法可以在新创建的对象上执行构造函数,用父类的构造函数来增加子类的实例</p>
<p>2.具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 子类</span><br><span class="line">function Sub()&#123;</span><br><span class="line">  Super.call(this)</span><br><span class="line">  this.property = &apos;Sub Property&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.优缺点<br>1）优点<br>简单明了，直接继承超类构造函数的属性和方法<br>2）缺点<br>无法继承原型链上的属性和方法</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>1.基本思想<br>利用原型链来实现继承，超类的一个实例作为子类的原型</p>
<p>2.具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 子类</span><br><span class="line">function Sub()&#123;</span><br><span class="line">  this.property = &apos;Sub Property&apos;</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = new Super()</span><br><span class="line">// 注意这里new Super()生成的超类对象并没有constructor属性,故需添加上</span><br><span class="line">Sub.prototype.constructor = Sub</span><br></pre></td></tr></table></figure></p>
<p>3.优缺点<br>1）优点<br>简单明了，容易实现<br>实例是子类的实例，实际上也是父类的一个实例<br>父类新增原型方法/原型属性，子类都能访问到<br>2）缺点<br>所有子类的实例的原型都共享同一个超类实例的属性和方法<br>无法实现多继承</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>1.基本思想<br>利用构造继承和原型链组合</p>
<p>2.具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 子类</span><br><span class="line">function Sub()&#123;</span><br><span class="line">  Super.call(this)</span><br><span class="line">  this.property = &apos;Sub Property&apos;</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = new Super()</span><br><span class="line">// 注意这里new Super()生成的超类对象并没有constructor属性,故需添加上</span><br><span class="line">Sub.prototype.constructor = Sub</span><br></pre></td></tr></table></figure></p>
<p>3.优缺点<br>1）优点<br>解决了构造继承和原型链继承的两个问题<br>2）缺点<br>实际上子类上会拥有超类的两份属性，只是子类的属性覆盖了超类的属性</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>1.基本思想<br>采用原型式继承并不需要定义一个类，传入参数obj,生成一个继承obj对象的对象</p>
<p>2.具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function objectCreate(obj)&#123;</span><br><span class="line">  function F()&#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.优缺点<br>1）优点：<br>直接通过对象生成一个继承该对象的对象<br>2）缺点：</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>1.基本思想<br>创建一个仅仅用于封装继承过程的函数，然后在内部以某种方式增强对象，最后返回对象</p>
<p>2.具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function objectCreate(obj)&#123;</span><br><span class="line">  function F()&#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br><span class="line">function createSubObj(superInstance)&#123;</span><br><span class="line">  var clone = objectCreate(superInstance)</span><br><span class="line">  clone.property = &apos;Sub Property&apos;</span><br><span class="line">  return clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.优缺点<br>1）优点：<br>原型式继承的一种拓展<br>2）缺点：<br>依旧没有类的概念</p>
<h2 id="六-寄生组合式继承"><a href="#六-寄生组合式继承" class="headerlink" title="六.寄生组合式继承"></a>六.寄生组合式继承</h2><p>1.基本思想<br>结合寄生式继承和组合式继承，完美实现不带两份超类属性的继承方式</p>
<p>2.具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(Super,Sub)&#123;</span><br><span class="line">  var superProtoClone = Object.Create(Super.prototype)</span><br><span class="line">  superProtoClone.constructor = Sub</span><br><span class="line">  Sub.prototype = Super</span><br><span class="line">&#125;</span><br><span class="line">function Sub()&#123;</span><br><span class="line">  Super.call()</span><br><span class="line">  Sub.property = &apos;Sub Property&apos;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Super,Sub)</span><br></pre></td></tr></table></figure></p>
<p>3.优缺点<br>1）优点：<br>完美实现继承，解决了组合式继承带两份属性的问题<br>2）缺点：<br>过于繁琐，故不如组合继承</p>

                
                <div class="readmore">
                    <a href="/2018/12/26/原型/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2018/12/26/面试CSS/">
                        CSS
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2018-12-26T09:28:15.000Z">
                            2018-12-26
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="响应式布局的常用解决方案对比-媒体查询、百分比、rem和vw-vh）"><a href="#响应式布局的常用解决方案对比-媒体查询、百分比、rem和vw-vh）" class="headerlink" title="响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh）"></a>响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh）</h1><p>简要介绍：前端开发中，静态网页通常需要适应不同分辨率的设备，常用的自适应解决方案包括媒体查询、百分比、rem和vw/vh等。本文从px单位出发，分析了px在移动端布局中的不足，接着介绍了几种不同的自适应解决方案。</p>
<ul>
<li>px和视口</li>
<li>媒体查询</li>
<li>百分比</li>
<li>自适应场景下的rem解决方案</li>
<li>通过vw/vh来实现自适应</li>
</ul>
<h2 id="px和视口"><a href="#px和视口" class="headerlink" title="px和视口"></a>px和视口</h2><p>在静态网页中，我们经常用像素（px）作为单位，来描述一个元素的宽高以及定位信息。在pc端，通常认为css中,1px所表示的真实长度是固定的。<br>那么，px真的是一个设备无关，跟长度单位米和分米一样是固定大小的吗？</p>
<p>答案是否定的，下面图1.1和图1.2分别表示pc端下和移动端下的显示结果，在网页中我们设置的font-size统一为16px。<br><img src="/2018/12/26/面试CSS/css01.png" alt=""><br>从上面两幅图的对比可以看出，字体都是16px，显然在pc端中文字正常显示，而在移动端文字很小，几乎看不到，说明在css中1px并不是固定大小，直观从我们发现在移动端1px所表示的长度较小，所以导致文字显示不清楚。</p>
<p>那么css中的1px的真实长度到底由什么决定呢？</p>
<p>为了理清楚这个概念我们首先介绍像素和视口的概念</p>
<h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>像素是网页布局的基础，一个像素表示了计算机屏幕所能显示的最小区域，像素分为两种类型：css像素和物理像素。</p>
<p>我们在js或者css代码中使用的px单位就是指的是css像素，物理像素也称设备像素，只与设备或者说硬件有关，同样尺寸的屏幕，设备的密度越高，物理像素也就越多。下表表示css像素和物理像素的具体区别：</p>
<blockquote>
<p>css像素:  为web开发者提供，在css中使用的一个抽象单位<br>物理像素 : 只与设备的硬件密度有关，任何设备的物理像素都是固定的<br>那么css像素与物理像素的转换关系是怎么样的呢？为了明确css像素和物理像素的转换关系，必须先了解视口是什么。</p>
</blockquote>
<h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>广义的视口，是指浏览器显示内容的屏幕区域，狭义的视口包括了布局视口、视觉视口和理想视口</p>
<p>(1) 布局视口（layout viewport）<br>布局视口定义了pc网页在移动端的默认布局行为，因为通常pc的分辨率较大，布局视口默认为980px。也就是说在不设置网页的viewport的情况下，pc端的网页默认会以布局视口为基准，在移动端进行展示。因此我们可以明显看出来，默认为布局视口时，根植于pc端的网页在移动端展示很模糊。</p>
<p>(2) 视觉视口（visual viewport）<br>视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。视觉视口的定义，就像拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。</p>
<p>(3) 理想视口（ideal viewport）<br>理想视口或者应该全称为“理想的布局视口”，在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。</p>
<p>上述视口中，最重要的是要明确理想视口的概念，在移动端中，理想视口或者说分辨率跟物理像素之间有什么关系呢？</p>
<p>为了理清分辨率和物理像素之间的联系，我们介绍一个用DPR（Device pixel ratio）设备像素比来表示，则可以写成：</p>
<p>1 DPR = 物理像素／分辨率<br>在不缩放的情况下，一个css像素就对应一个dpr，也就是说，在不缩放</p>
<p>1 CSS像素 = 物理像素／分辨率<br>此外，在移动端的布局中，我们可以通过viewport元标签来控制布局，比如一般情况下，我们可以通过下述标签使得移动端在理想视口下布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta id=&quot;viewport&quot; name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0; maximum-scale=1; user-scalable=no;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td>正整数</td>
<td>定义布局视口的宽度，单位为像素</td>
</tr>
<tr>
<td>height</td>
<td>正整数</td>
<td>定义布局视口的高度，单位为像素，很少使用</td>
</tr>
<tr>
<td>initial-scale</td>
<td>[0,10]</td>
<td>初始缩放比例，1表示不缩放</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>[0,10]</td>
<td>最小缩放比例</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>[0,10]</td>
<td>最大缩放比例</td>
</tr>
<tr>
<td>user-scalable</td>
<td>yes／no</td>
<td>是否允许手动缩放页面，默认值为yes</td>
</tr>
</tbody>
</table>
<p>其中我们来看width属性，在移动端布局时，在meta标签中我们会将width设置称为device-width，device-width一般是表示分辨率的宽，通过width=device-width的设置我们就将布局视口设置成了理想的视口。</p>
<h3 id="px与自适应"><a href="#px与自适应" class="headerlink" title="px与自适应"></a>px与自适应</h3><p>上述我们了解到了当通过viewport元标签，设置布局视口为理想视口时，1个css像素可以表示成：</p>
<p>1 CSS像素 = 物理像素／分辨率<br>我们直到，在pc端的布局视口通常情况下为980px，移动端以iphone6为例，分辨率为375 <em> 667，也就是说布局视口在理想的情况下为375px。比如现在我们有一个750px </em> 1134px的视觉稿，那么在pc端，一个css像素可以如下计算：</p>
<p>PC端： 1 CSS像素 = 物理像素／分辨率 = 750 ／ 980 =0.76 px<br>而在iphone6下：</p>
<p>iphone6：1 CSS像素 = 物理像素 ／分辨率 = 750 ／ 375 = 2 px<br>也就是说在PC端，一个CSS像素可以用0.76个物理像素来表示，而iphone6中 一个CSS像素表示了2个物理像素。此外不同的移动设备分辨率不同，也就是1个CSS像素可以表示的物理像素是不同的，因此如果在css中仅仅通过px作为长度和宽度的单位，造成的结果就是无法通过一套样式，实现各端的自适应。</p>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>在前面我们说到，不同端的设备下，在css文件中，1px所表示的物理像素的大小是不同的，因此通过一套样式，是无法实现各端的自适应。由此我们联想：</p>
<p>如果一套样式不行，那么能否给每一种设备各一套不同的样式来实现自适应的效果？</p>
<p>答案是肯定的。</p>
<p>使用@media媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果。举例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width: 960px)&#123;</span><br><span class="line">    body&#123;</span><br><span class="line">      background-color:#FF6699</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width: 768px)&#123;</span><br><span class="line">    body&#123;</span><br><span class="line">      background-color:#00FF66;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width: 550px)&#123;</span><br><span class="line">    body&#123;</span><br><span class="line">      background-color:#6633FF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width: 320px)&#123;</span><br><span class="line">    body&#123;</span><br><span class="line">      background-color:#FFFF00;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述的代码通过媒体查询定义了几套样式，通过max-width设置样式生效时的最大分辨率，上述的代码分别对分辨率在0～320px，320px～550px，550px～768px以及768px～960px的屏幕设置了不同的背景颜色。</p>
<p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x图，为大屏幕手机设置@3X图，通过媒体查询就能很方便的实现。</p>
<p>但是媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</p>
<h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><p>除了用px结合媒体查询实现响应式布局外，我们也可以通过百分比单位 “ % “ 来实现响应式的效果。</p>
<p>比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。</p>
<p>为了了解百分比布局，首先要了解的问题是：</p>
<p>css中的子元素中的百分比（%）到底是谁的百分比？</p>
<p>直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height百分比相对于height，width百分比相对于width。当然这种理解是正确的，但是根据css的盒式模型，除了height、width属性外，还具有padding、border、margin等等属性。那么这些属性设置成百分比，是根据父元素的那些属性呢？此外还有border-radius和translate等属性中的百分比，又是相对于什么呢？下面来具体分析。</p>
<ol>
<li>百分比的具体分析<br>（1）子元素height和width的百分比</li>
</ol>
<p>子元素的height或width中使用百分比，是相对于子元素的直接父元素，width相对于父元素的width，height相对于父元素的height。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">如果设置：</span><br><span class="line">.father&#123;</span><br><span class="line">width:200px;</span><br><span class="line">height:100px;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">width:50%;</span><br><span class="line">height:50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>展示的效果为：<br><img src="/2018/12/26/面试CSS/css02.png" alt=""><br>(2) top和bottom 、left和right</p>
<p>子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度，同样</p>
<p>子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度。</p>
<p>展示的效果为：<br><img src="/2018/12/26/面试CSS/css03.png" alt=""><br>（3）padding</p>
<p>子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。</p>
<p>举例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">  width:200px;</span><br><span class="line">  height:100px;</span><br><span class="line">  background:green;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">  width:0px;</span><br><span class="line">  height:0px;</span><br><span class="line">  background:blue;</span><br><span class="line">  color:white;</span><br><span class="line">  padding-top:50%;</span><br><span class="line">  padding-left:50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>展示的效果为：<br><img src="/2018/12/26/面试CSS/css04.png" alt=""><br>子元素的初始宽高为0，通过padding可以将父元素撑大，上图的蓝色部分是一个正方形，且边长为100px,说明padding不论宽高，如果设置成百分比都相对于父元素的width。</p>
<p>（4）margin</p>
<p>跟padding一样，margin也是如此，子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width。这里就不具体举例。</p>
<p>（5）border-radius</p>
<p>border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度，举例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;trangle&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>设置border-radius为百分比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.trangle&#123;</span><br><span class="line">  width:100px;</span><br><span class="line">  height:100px;</span><br><span class="line">  border-radius:50%;</span><br><span class="line">  background:blue;</span><br><span class="line">  margin-top:10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>展示效果为：</p>
<p><img src="/2018/12/26/面试CSS/css06.gif" alt=""></p>
<ol start="2">
<li>百分比单位布局应用<br>百分比单位在布局上应用还是很广泛的，这里介绍一种应用。<br>比如我们要实现一个固定长宽比的长方形，比如要实现一个长宽比为4:3的长方形,我们可以根据padding属性来实现，因为padding不管是垂直方向还是水平方向，百分比单位都相对于父元素的宽度，因此我们可以设置padding-top为百分比来实现，长宽自适应的长方形：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;trangle&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>设置样式让其自适应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.trangle&#123;</span><br><span class="line">  height:0;</span><br><span class="line">  width:100%;</span><br><span class="line">  padding-top:75%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过设置padding-top：75%,相对比宽度的75%，因此这样就设置了一个长宽高恒定比例的长方形，具体效果<br><img src="/2018/12/26/面试CSS/css05.png" alt=""></p>
<ol start="3">
<li>百分比单位缺点<br>从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：<br>（1）计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。<br>（2）从小节1可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</li>
</ol>
<h2 id="自适应场景下的rem解决方案"><a href="#自适应场景下的rem解决方案" class="headerlink" title="自适应场景下的rem解决方案"></a>自适应场景下的rem解决方案</h2><ol>
<li>rem单位</li>
</ol>
<p>首先来看，什么是rem单位。rem是一个灵活的、可扩展的单位，由浏览器转化像素并显示。与em单位不同，rem单位无论嵌套层级如何，都只相对于浏览器的根元素（HTML元素）的font-size。默认情况下，html元素的font-size为16px，所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 rem = 12px</span><br></pre></td></tr></table></figure></p>
<p>为了计算方便，通常可以将html的font-size设置成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html&#123; font-size: 62.5% &#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 rem = 10px</span><br></pre></td></tr></table></figure></p>
<p>2.通过rem来实现响应式布局</p>
<p>rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。<br>因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function refreshRem() &#123;</span><br><span class="line">    var docEl = doc.documentElement;</span><br><span class="line">    var width = docEl.getBoundingClientRect().width;</span><br><span class="line">    var rem = width / 10;</span><br><span class="line">    docEl.style.fontSize = rem + &apos;px&apos;;</span><br><span class="line">    flexible.rem = win.rem = rem;</span><br><span class="line">&#125;</span><br><span class="line">win.addEventListener(&apos;resize&apos;, refreshRem);</span><br></pre></td></tr></table></figure></p>
<p>上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。</p>
<ol start="3">
<li>rem2px和px2rem</li>
</ol>
<p>如果在响应式布局中使用rem单位，那么存在一个单位换算的问题，rem2px表示从rem换算成px，这个就不说了，只要rem乘以相应的font-size中的大小，就能换算成px。更多的应用是px2rem，表示的是从px转化为rem。</p>
<p>比如给定的视觉稿为750px（物理像素），如果我们要将所有的布局单位都用rem来表示，一种比较笨的办法就是对所有的height和width等元素，乘以相应的比例，现将视觉稿换算成rem单位，然后一个个的用rem来表示。另一种比较方便的解决方法就是，在css中我们还是用px来表示元素的大小，最后编写完css代码之后，将css文件中的所有px单位，转化成rem单位。</p>
<p>px2rem的原理也很简单，重点在于预处理以px为单位的css文件，处理后将所有的px变成rem单位。可以通过两种方式来实现：</p>
<p>1） webpack loader的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install px2rem-loader</span><br></pre></td></tr></table></figure></p>
<p>在webpack的配置文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      use: [&#123;</span><br><span class="line">        loader: &apos;style-loader&apos;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: &apos;css-loader&apos;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        loader: &apos;px2rem-loader&apos;,</span><br><span class="line">        // options here</span><br><span class="line">        options: &#123;</span><br><span class="line">          remUni: 75,</span><br><span class="line">          remPrecision: 8</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）webpack中使用postcss plugin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader</span><br></pre></td></tr></table></figure></p>
<p>在webpack的plugin中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var px2rem = require(&apos;postcss-px2rem&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        loader: &quot;style-loader!css-loader!postcss-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  postcss: function() &#123;</span><br><span class="line">    return [px2rem(&#123;remUnit: 75&#125;)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>rem 布局应用举例</li>
</ol>
<p>网易新闻的移动端页面使用了rem布局，具体例子如下：</p>
<p><img src="/2018/12/26/面试CSS/css07.gif" alt=""></p>
<ol start="5">
<li>rem 布局的缺点</li>
</ol>
<p>通过rem单位，可以实现响应式的布局，特别是引入相应的postcss相关插件，免去了设计稿中的px到rem的计算。rem单位在国外的一些网站也有使用，这里所说的rem来实现布局的缺点，或者说是小缺陷是：</p>
<p>在响应式布局中，必须通过js来动态控制根元素font-size的大小。</p>
<p>也就是说css样式和js代码有一定的耦合性。且必须将改变font-size的代码放在css样式之前。</p>
<h2 id="通过vw-vh来实现自适应"><a href="#通过vw-vh来实现自适应" class="headerlink" title="通过vw/vh来实现自适应"></a>通过vw/vh来实现自适应</h2><ol>
<li>什么是vw/vh ?</li>
</ol>
<p>css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。各个单位具体的含义如下：</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>vw</td>
<td>相对于视窗的宽度，视窗宽度是100vw</td>
</tr>
<tr>
<td>vh</td>
<td>相对于视窗的高度，视窗高度是100vh</td>
</tr>
<tr>
<td>vmin</td>
<td>vw和vh中的较小值</td>
</tr>
<tr>
<td>vmax</td>
<td>vw和vh中的较大值</td>
</tr>
</tbody>
</table>
<p>这里我们发现视窗宽高都是100vw／100vh，那么vw或者vh，下简称vw，很类似百分比单位。vw和%的区别为：</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</td>
</tr>
<tr>
<td>vw/vh</td>
<td>相对于视窗的尺寸</td>
</tr>
</tbody>
</table>
<p>从对比中我们可以发现，vw单位与百分比类似，单确有区别，前面我们介绍了百分比单位的换算困难，这里的vw更像”理想的百分比单位”。任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。</p>
<ol start="2">
<li>vw单位换算</li>
</ol>
<p>同样的，如果要将px换算成vw单位，很简单，只要确定视图的窗口大小（布局视口），如果我们将布局视口设置成分辨率大小，比如对于iphone6/7 375*667的分辨率，那么px可以通过如下方式换算成vw：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1px = （1/375）*100 vw</span><br></pre></td></tr></table></figure></p>
<p>此外，也可以通过postcss的相应插件，预处理css做一个自动的转换，postcss-px-to-viewport可以自动将px转化成vw。<br>postcss-px-to-viewport的默认参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var defaults = &#123;</span><br><span class="line">  viewportWidth: 320,</span><br><span class="line">  viewportHeight: 568, </span><br><span class="line">  unitPrecision: 5,</span><br><span class="line">  viewportUnit: &apos;vw&apos;,</span><br><span class="line">  selectorBlackList: [],</span><br><span class="line">  minPixelValue: 1,</span><br><span class="line">  mediaQuery: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过指定视窗的宽度和高度，以及换算精度，就能将px转化成vw。</p>
<ol start="3">
<li>vw/vh单位的兼容性<br>可以在<a href="https://caniuse.com/" target="_blank" rel="noopener">https://caniuse.com/</a> 查看各个版本的浏览器对vw单位的支持性。<br>从上图我们发现，绝大多数的浏览器支持vw单位，但是ie9-11不支持vmin和vmax，考虑到vmin和vmax单位不常用，vw单位在绝大部分高版本浏览器内的支持性很好，但是opera浏览器整体不支持vw单位，如果需要兼容opera浏览器的布局，不推荐使用vw。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍在布局中常用的单位，比如px、%、rem和vw等等，以及不同的单位在响应式布局中的优缺点。</p>
<h1 id="画一条0-5px的线"><a href="#画一条0-5px的线" class="headerlink" title="画一条0.5px的线"></a>画一条0.5px的线</h1><ul>
<li><p>采用meta viewport的方式</p>
</li>
<li><p>采用 border-image的方式</p>
</li>
<li><p>采用transform: scale()的方式</p>
</li>
</ul>
<h1 id="link标签和import标签的区别"><a href="#link标签和import标签的区别" class="headerlink" title="link标签和import标签的区别"></a>link标签和import标签的区别</h1><ul>
<li>link属于html标签，而@import是css提供的</li>
<li>页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。</li>
<li>link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。</li>
<li>link方式样式的权重高于@import的。</li>
</ul>
<h1 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h1><p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。</p>
<h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p>文章链接：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool（语法篇）" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool（语法篇）</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html（实例篇）" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html（实例篇）</a></p>
<p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>
<p>简单的分为容器属性和元素属性<br>容器的属性：</p>
<p>flex-direction：决定主轴的方向（即子item的排列方法）<br>.box {<br>flex-direction: row | row-reverse | column | column-reverse;<br>}<br>flex-wrap：决定换行规则<br>.box{<br>flex-wrap: nowrap | wrap | wrap-reverse;<br>}<br>flex-flow：<br>.box {<br>flex-flow: || ;<br>}<br>justify-content：对其方式，水平主轴对齐方式<br>align-items：对齐方式，竖直轴线方向<br>项目的属性（元素的属性）：</p>
<p>order属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为0<br>flex-grow属性：定义项目的放大比例，即使存在空间，也不会放大<br>flex-shrink属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个item的flow-shrink为0，则为不缩小<br>flex-basis属性：定义了在分配多余的空间，项目占据的空间。<br>flex：是flex-grow和flex-shrink、flex-basis的简写，默认值为0 1 auto。<br>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items，默认属性为auto，表示继承父元素的align-items<br>比如说，用flex实现圣杯布局</p>
<h1 id="BFC（块级格式化上下文，用于清除浮动，防止margin重叠等）"><a href="#BFC（块级格式化上下文，用于清除浮动，防止margin重叠等）" class="headerlink" title="BFC（块级格式化上下文，用于清除浮动，防止margin重叠等）"></a>BFC（块级格式化上下文，用于清除浮动，防止margin重叠等）</h1><p>直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。</p>
<p>BFC区域不会与float box重叠<br>BFC是页面上的一个独立容器，子元素不会影响到外面<br>计算BFC的高度时，浮动元素也会参与计算<br>哪些元素会生成BFC：</p>
<p>根元素</p>
<ul>
<li>float不为none的元素</li>
<li>position为fixed和absolute的元素</li>
<li>display为inline-block、table-cell、table-caption，flex，inline-flex的元素</li>
<li>overflow不为visible的元素</li>
</ul>
<blockquote>
<p>BFC定义</p>
</blockquote>
<p>1、 box<br>box是css布局的基本单位，元素的类型和display属性决定了box的类型。不同的类型的盒子会参与不同的formatting context。<br>block-level box :display属性为block、list-item(作为列表显示的元素)、table的元素会生成block-level box。<br>2、formatting context<br>它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用</p>
<p>BFC（block formatting context）为块级格式化上下文，他是一个独立渲染区域，并且只有block-level box参与，规定了block-level box内部的布局方式。</p>
<blockquote>
<p>布局规则</p>
</blockquote>
<ul>
<li><p>1、内部的box会在垂直方向上一个接一个的放置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"div1"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"div2"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、同一个bfc内，两个相邻box元素的margin会产生重叠，重叠距离为数值大的margin值<br>给div1设置margin: 20px 0,给div2设置margin: 30px 0,此时div1和div2之间的间距为30px。</p>
</li>
</ul>
<p>解决方式  让两个元素不属于同一个BFC<br>3、BFC区域不会与浮动元素重叠<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"left"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"main"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>此时main元素没有产生bfc,left元素浮动，效果如下：<br>给main元素设置overflow:hidden变为bfc,效果如下：</p>
<ul>
<li>4、计算BFC的高度时，浮动元素也参与计算</li>
<li>5、每个元素的margin box的左边， 与 包含块 border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</li>
<li>6、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素<blockquote>
<p>3、产生BFC的方式</p>
</blockquote>
</li>
<li>1、overflow属性不是visible</li>
<li>2、float属性不为none</li>
<li>3、display属性为inline-block、table-cell、flex、inline-flex、table-caption</li>
<li>4、position为absolute、fixed</li>
<li>5、body根元素</li>
</ul>
<h1 id="关于js动画和css3动画的差异性"><a href="#关于js动画和css3动画的差异性" class="headerlink" title="关于js动画和css3动画的差异性"></a>关于js动画和css3动画的差异性</h1><p>渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个CSS动画得以在compositor trhead完成（而js动画则会在main thread执行，然后出发compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout或者paint的。<br>区别：</p>
<ul>
<li>功能涵盖面，js比css大</li>
<li>实现/重构难度不一，CSS3比js更加简单，性能跳优方向固定</li>
<li>对帧速表现不好的低版本浏览器，css3可以做到自然降级</li>
<li>css动画有天然事件支持</li>
<li>css3有兼容性问题</li>
</ul>
<h1 id="块元素和行元素"><a href="#块元素和行元素" class="headerlink" title="块元素和行元素"></a>块元素和行元素</h1><p>HTML可以将元素分类方式分为行内元素、块状元素和行内块状元素三种。首先需要说明的是，这三者是可以互相转换的，使用display属性能够将三者任意转换：</p>
<p>　　(1)display:inline;转换为行内元素</p>
<p>　　(2)display:block;转换为块状元素</p>
<p>　　(3)display:inline-block;转换为行内块状元素<br>块元素：独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度<br>行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失<br>效。<br>1.块状元素<br>　　块状元素代表性的就是div，其他如p、nav、aside、header、footer、section、article、ul-li、address等等，都可以用div来实现。不过为了可以方便程序员解读代码，一般都会使用特定的语义化标签，使得代码可读性强，且便于查错。</p>
<p>　　块状元素特征：(1)能够识别宽高</p>
<p>　　　　　　　　　(2)margin和padding的上下左右均对其有效</p>
<p>　　　　　　　　　(3)可以自动换行</p>
<p>　　　　　　　　　(4)多个块状元素标签写在一起，默认排列方式为从上至下<br>2.块状元素<br>　　块状元素代表性的就是div，其他如p、nav、aside、header、footer、section、article、ul-li、address等等，都可以用div来实现。不过为了可以方便程序员解读代码，一般都会使用特定的语义化标签，使得代码可读性强，且便于查错。</p>
<p>　　块状元素特征：(1)能够识别宽高</p>
<p>　　　　　　　　　(2)margin和padding的上下左右均对其有效</p>
<p>　　　　　　　　　(3)可以自动换行</p>
<p>　　　　　　　　　(4)多个块状元素标签写在一起，默认排列方式为从上至下<br>3.行内块状元素<br>　　行内块状元素综合了行内元素和块状元素的特性，但是各有取舍。因此行内块状元素在日常的使用中，由于其特性，使用的次数也比较多。</p>
<p>　　行内块状元素特征：(1)不自动换行</p>
<p>　　　　　　　　　　　(2)能够识别宽高</p>
<p>　　　　　　　　　　　(3)默认排列方式为从左到右</p>
<h1 id="多行元素的文本省略号"><a href="#多行元素的文本省略号" class="headerlink" title="多行元素的文本省略号"></a>多行元素的文本省略号</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box</span><br><span class="line">-webkit-box-orient:vertical</span><br><span class="line">-webkit-line-clamp:3</span><br><span class="line">overflow:hidden</span><br></pre></td></tr></table></figure>
<h1 id="visibility-hidden-opacity-0，display-none"><a href="#visibility-hidden-opacity-0，display-none" class="headerlink" title="visibility=hidden, opacity=0，display:none"></a>visibility=hidden, opacity=0，display:none</h1><p>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</p>
<h1 id="双边距重叠问题（外边距折叠）"><a href="#双边距重叠问题（外边距折叠）" class="headerlink" title="双边距重叠问题（外边距折叠）"></a>双边距重叠问题（外边距折叠）</h1><p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠</p>
<p>折叠的结果为：</p>
<p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。<br>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。<br>两个外边距一正一负时，折叠结果是两者的相加的和。</p>
<h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><ul>
<li>static  默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。</li>
<li>relative  位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此 “left:20” 会将元素移至元素正常位置左边 20 个像素的位置。</li>
<li>absolute  位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。</li>
<li>fixed 位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及”bottom” 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。</li>
<li>sticky 基于用户的滚动位置来定位。粘性定位的元素是依赖于用户的滚动，在position:relative 与 position:fixed定位之间切换。它的行为就像position:relative;而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</li>
</ul>
<h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h1><p>语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@keyframes animationname &#123;keyframes-selector &#123;css-styles;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的表格列出了 @keyframes 规则和所有动画属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>@keyframes</td>
<td>规定动画。</td>
<td>3</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性，除了 animation-play-state 属性。</td>
<td>3</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定 @keyframes 动画的名称。</td>
<td>3</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td>
<td>3</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线。默认是 “ease”。</td>
<td>3</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始。默认是 0。</td>
<td>3</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数。默认是 1。</td>
<td>3</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td>
<td>3</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停。默认是 “running”。</td>
<td>3</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定对象动画时间之外的状态。</td>
<td>3</td>
</tr>
</tbody>
</table>
<h1 id="伪元素伪类"><a href="#伪元素伪类" class="headerlink" title="伪元素伪类"></a>伪元素伪类</h1><blockquote>
<p>css3为了区分伪类和伪元素，伪元素采用双冒号写法。</p>
</blockquote>
<p>伪类 – :hover, :link, :active, :visited, :first-child, :last-child, nth-child(n), :not(), :focus<br>伪元素 – ::before, ::after, ::first-letter, ::first-line, ::selection</p>
<blockquote>
<p>定义:</p>
</blockquote>
<p>伪类：用于向某些选择器添加特殊的效果<br>伪元素：用于将特殊的效果添加到某些选择器</p>
<blockquote>
<p>区别</p>
</blockquote>
<p>例子来理解<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;em&gt;This&lt;/em&gt;</span><br><span class="line">    &lt;em&gt;is a text&lt;/em&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/12/26/面试CSS/weilei01.png" alt=""><br>如果我们想要第一个em标签字体颜色变红怎么做呢<br>使用我们熟悉的伪类很简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">em:first-child &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/12/26/面试CSS/weilei02.png" alt=""><br>但是如果不存在伪类我们怎么做呢<br>这是我们就需要为第一个em标签添加类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;em class=&quot;first-child&quot;&gt;This&lt;/em&gt;</span><br><span class="line">    &lt;em&gt;is a text&lt;/em&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">em.first-child &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以实现同样的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;em&gt;This&lt;/em&gt;</span><br><span class="line">    &lt;em&gt;is a text&lt;/em&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>还是这个例子<br>现在我想让这个段落的第一个字母变红 </p>
<p>这回我们需要使用伪元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p::first-letter &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/12/26/面试CSS/weilei03.png" alt=""><br>同样假设伪元素不存在的情况<br>这时我们只能嵌套span标签来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;em&gt;&lt;span&gt;T&lt;/span&gt;his&lt;/em&gt;</span><br><span class="line">    &lt;em&gt;is a text&lt;/em&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">p span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里，相信大家已经清楚了为什么一个叫做伪类，一个叫做伪元素<br>伪类的效果可以通过添加实际的类来实现<br>伪元素的效果可以通过添加实际的元素来实现 </p>
<p><font color="red">它们的本质区别就是是否抽象创造了新元素</font><br>伪元素是可以设置content属性的，类似于标签，但是伪类只能设置样式不能设置内容。<br><strong>注意</strong><br>伪类就像真正的类一样，可以叠加使用<br>没有数量上限，只要不是互斥的<br>比如这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">em:first-child:hover &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但注意，这里是“与”的关系<br>也就是说既要满足“first-child”第一个子元素<br>又要满足“hover”光标悬浮<br>伪元素就要严格的多<br>伪元素在一个选择器中只能出现一次，并且只能出现在末尾<br>（这里有同学误会了，所以我作出了修改）<br>像下面的样式是无法生效的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p::first-letter:hover &#123;  /*错误的写法：伪元素不是末尾*/</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">p::first-letter::selection &#123;  /*错误的写法：伪元素出现了多个*/</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于它们的优先级<br>在计算权重的时候<br>伪类与类优先级相同<br>伪元素与标签优先级相同</p>
<p><strong>总结</strong></p>
<ul>
<li>伪类与伪元素都是用于向选择器加特殊效果</li>
<li>伪类与伪元素的本质区别就是是否抽象创造了新元素</li>
<li>伪类只要不是互斥可以叠加使用</li>
<li>伪元素在一个选择器中只能出现一次，并且只能出现在末尾</li>
<li>伪类与伪元素优先级分别与类、标签优先级相同</li>
</ul>

                
                <div class="readmore">
                    <a href="/2018/12/26/面试CSS/">
                        阅读更多
                    </a>
                </div>
            </div>
        
    </div>


    <div id="content-aside">
    <div class="content-aside-owner">
        <div id="owner">
    <div class="avatar-bg">
        <div class="index-page">
            <div class="banner">
                <div class="slide slide1">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_left">
                            <div id="canvas_left"></div>
                        </div>
                    </div>
                </div>
                <div class="slide slide2">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_right">
                            <div id="canvas_right"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a href="/"><img class="avatar" src="/images/avatar.jpg" alt=""></a>
    <a href="/"><h3 class="author">I&#39;m xiedandan</h3></a>
    <h4>^_^</h4>
    <div class="social">
        
            
              <a href="https://github.com/xdd7130" title="github" class="fa fa-github" target="_blank"></a>
            
        
            
              <a href="#" title="weibo" class="fa fa-weibo" target="_blank"></a>
            
        
    </div>
</div>
    </div>
    
        <div class="content-aside-about">
            <h2>
                <a href="/about">关于</a>
            </h2>
        </div>
    
    <div class="content-aside-tags">
        <h2>
            <a href="/tags">
                标签
                <sup style="font-size: 12px">
                    [32]
                </sup>
            </a>
        </h2>
    </div>
    
<aside id="categories">
    <h2>分类</h2>
    
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ArcGIS/">ArcGIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cesium/">Cesium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小程序/">小程序</a></li></ul>
    
</aside>

    
<aside id="acchives">
    <h2>归档</h2>
    
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    
</aside>

</div>

</div>
<nav id="pagination" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span>
</nav>

    </div>
</div>
<footer id="footer">
     <div id="copyright">&copy; I&#39;m xiedandan  2021</div>
     
             <!-- 不蒜子统计 -->
             <span id="busuanzi_container_site_pv">
                     本站总访问量<span id="busuanzi_value_site_pv" style='color:#17a167'></span>次
             </span>
             <span class="post-meta-divider">|</span>
             <span id="busuanzi_container_site_uv">
                     本站访客数<span id="busuanzi_value_site_uv"  style='color:#17a167'></span>人
             </span>
             <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
       
    <div id="theme">
        Powered by <a href="http://hexo.io">Hexo</a>. Theme by <a href="https://github.com/markyong/hexo-theme-stage">Stage</a>
    </div>
</footer>
<script src="/lib/js/waterrippleeffect.min.js"></script>
<script src="/js/header-bg.main.js"></script>

    <script src="/lib/js/cav.js"></script>
    <script src="/js/avatar-bg.main.js"></script>

</body>
</html>
