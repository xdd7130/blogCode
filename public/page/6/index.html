
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <title>DD_XIE的学习笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="">
    <meta name="description" content="前端学习">
    
        <link rel="icon" href="/favicon.ico">
    
    
        
            <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
        
            <link rel="stylesheet" href="/css/stage.css">
        
            <link rel="stylesheet" href="/css/avatar-bg.css">
        
    
</head>
</html>
<body>
<header id="header">
    <div class="menu">
        <i class="fa fa-bars"></i>
    </div>
    <div class="header-main">
        <h1><a href="/">DD_XIE的学习笔记</a></h1>
    </div>
    <div id="nav">
        <div class="nav-img" id="nav-img"></div>
        <div class="sentences">
            时光荏苒，旦夕之间，略有遗憾，似白驹过隙，蹉跎自悟。
        </div>
    </div>
</header>

<div id="content-outer">
    <div id="content-inner">
        <div class="clearfix">
    
    <div id="recent-posts">
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/07/Promise/">
                        Promise
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-07T02:25:07.000Z">
                            2019-01-07
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <blockquote>
<p>参考:<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a></p>
<ul>
<li>Promise.prototype.then()</li>
<li>Promise.prototype.catch()</li>
<li>Promise.prototype.finally()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
<li>Promise.resolve()</li>
<li>Promise.reject()</li>
<li>Promise.try()</li>
</ul>
</blockquote>
<p>这里仅讨论.then()</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<p>首先，Promise 是一个对象，也是一个构造函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f1(resolve, reject) &#123;</span><br><span class="line">  // 异步代码</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Promise(f1)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Promise构造函数接受一个回调函数f1作为参数，f1里面是异步操作的代码。然后，返回的p1就是一个 Promise 实例。</p>
<p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(f1);</span><br><span class="line">p1.then(f2);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，f1的异步操作执行完成，就会执行f2。</p>
<p>传统的写法可能需要把f2作为回调函数传入f1，比如写成f1(f2)，异步操作完成后，在f1内部调用f2。Promise 使得f1和f2变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">step1(<span class="keyword">function</span> (value1) &#123;</span><br><span class="line">  step2(value1, <span class="keyword">function</span>(value2) &#123;</span><br><span class="line">    step3(value2, <span class="keyword">function</span>(value3) &#123;</span><br><span class="line">      step4(value3, <span class="keyword">function</span>(value4) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Promise 的写法</span><br><span class="line">(new Promise(step1))</span><br><span class="line">  .<span class="keyword">then</span>(step2)</span><br><span class="line">  .<span class="keyword">then</span>(step3)</span><br><span class="line">  .<span class="keyword">then</span>(step4);</span><br></pre></td></tr></table></figure></p>
<p>从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的Promise实例的生成格式，做了简化，真正的语法请参照下文。</p>
<p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p>
<p>Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。</p>
<h1 id="Promise-对象的状态"><a href="#Promise-对象的状态" class="headerlink" title="Promise 对象的状态"></a>Promise 对象的状态</h1><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<blockquote>
<blockquote>
<p>》异步操作未完成（pending）<br>》异步操作成功（fulfilled）<br>》异步操作失败（rejected）</p>
</blockquote>
</blockquote>
<p>上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。</p>
<p>这三种的状态的变化途径只有两种。</p>
<blockquote>
<p>》从“未完成”到“成功”<br>》从“未完成”到“失败”</p>
</blockquote>
<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p>
<p>因此，Promise 的最终结果只有两种。</p>
<blockquote>
<p>》异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。<br>》异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected</p>
</blockquote>
<h1 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h1><p>JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; /* 异步操作失败 */</span><br><span class="line">    reject(new Error());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>
<p>resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>下面是一个例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).<span class="keyword">then</span>(<span class="keyword">function</span>(val)&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;)</span><br><span class="line">或</span><br><span class="line">timeout(100).<span class="keyword">then</span>((val)=&gt;&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，timeout(100)返回一个Promise实例。100毫秒以后，该实例的状态会变为fulfilled</p>
<h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>Promise 实例的then方法，用来添加回调函数。</p>
<p>then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(<span class="string">'成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(console.log, console.error);</span><br><span class="line">// <span class="string">"成功"</span></span><br><span class="line"></span><br><span class="line">var p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  reject(new Error(<span class="string">'失败'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(console.log, console.error);</span><br><span class="line">// Error: 失败</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p1和p2都是Promise 实例，它们的then方法绑定两个回调函数：成功时的回调函数console.log，失败时的回调函数console.error（可以省略）。p1的状态变为成功，p2的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。</p>
<p>then方法可以链式使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br><span class="line">  .<span class="keyword">then</span>(step1)</span><br><span class="line">  .<span class="keyword">then</span>(step2)</span><br><span class="line">  .<span class="keyword">then</span>(step3)</span><br><span class="line">  .<span class="keyword">then</span>(</span><br><span class="line">    console.log,</span><br><span class="line">    console.error</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。</p>
<p>最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise 开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。</p>
<h1 id="then-用法辨析"><a href="#then-用法辨析" class="headerlink" title="then() 用法辨析"></a>then() 用法辨析</h1><p>Promise 的用法，简单说就是一句话：使用then方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">f1().<span class="keyword">then</span>(f2());</span><br><span class="line"></span><br><span class="line">// 写法四</span><br><span class="line">f1().<span class="keyword">then</span>(f2);</span><br></pre></td></tr></table></figure></p>
<p>为了便于讲解，下面这四种写法都再用then方法接一个回调函数f3。写法一的f3回调函数的参数，是f2函数的运行结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> f2();</span><br><span class="line">&#125;).<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法二的f3回调函数的参数是undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  f2();</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法三的f3回调函数的参数，是f2函数返回的函数的运行结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(f2())</span><br><span class="line">  .<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法四与写法一只有一个差别，那就是f2会接收到f1()返回的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(f2)</span><br><span class="line">  .<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p>
<p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>
<p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p>
<h1 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h1><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">&#125;).<span class="keyword">then</span>(console.log);</span><br><span class="line"></span><br><span class="line">console.log(2);</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码会先输出2，再输出1。因为console.log(2)是同步任务，而then的回调函数属于异步任务，一定晚于同步任务执行。</p>
<p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(2);</span><br><span class="line">&#125;).<span class="keyword">then</span>(console.log);</span><br><span class="line"></span><br><span class="line">console.log(3);</span><br><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。</p>

                
                <div class="readmore">
                    <a href="/2019/01/07/Promise/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/05/垂直居中/">
                        垂直居中
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-05T01:25:40.000Z">
                            2019-01-05
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="16种方法实现水平居中垂直居中"><a href="#16种方法实现水平居中垂直居中" class="headerlink" title="16种方法实现水平居中垂直居中"></a>16种方法实现水平居中垂直居中</h1><p>熟悉水平居中和垂直居中的方法, 不为别的, 就为用的时候能够信手拈来. 下面直接步入正题.<br>原文：16种方法实现水平居中垂直居中</p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>1) 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中.</p>
<p>2) 若是块级元素, 该元素设置 margin:0 auto即可.</p>
<p>3) 若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    width: -moz-fit-content;</span><br><span class="line">    width: -webkit-fit-content;</span><br><span class="line">    width:fit-content;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器.</p>
<p>4) 使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下:</p>
<p>.son{<br>    display: flex;<br>    justify-content: center;<br>}复制代码<br>5) 使用flex 2009年版本, 父元素display: box;box-pack: center;如下设置:</p>
<p>.parent {<br>    display: -webkit-box;<br>    -webkit-box-orient: horizontal;<br>    -webkit-box-pack: center;<br>    display: -moz-box;<br>    -moz-box-orient: horizontal;<br>    -moz-box-pack: center;<br>    display: -o-box;<br>      -o-box-orient: horizontal;<br>      -o-box-pack: center;<br>      display: -ms-box;<br>      -ms-box-orient: horizontal;<br>      -ms-box-pack: center;<br>      display: box;<br>      box-orient: horizontal;<br>      box-pack: center;<br>}复制代码<br>6) 使用CSS3中新增的transform属性, 子元素设置如下:</p>
<p>.son{<br>    position:absolute;<br>      left:50%;<br>      transform:translate(-50%,0);<br>}复制代码<br>7) 使用绝对定位方式, 以及负值的margin-left, 子元素设置如下:</p>
<p>.son{<br>    position:absolute;<br>    width:固定;<br>    left:50%;<br>    margin-left:-0.5宽度;<br>}复制代码<br>8) 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下:</p>
<p>.son{<br>    position:absolute;<br>    width:固定;<br>    left:0;<br>    right:0;<br>    margin:0 auto;<br>}复制代码</p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><p>1) 若元素是单行文本, 则可设置 line-height 等于父元素高度</p>
<h3 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h3><p>2) 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央.</p>
<p>.parent::after, .son{<br>    display:inline-block;<br>    vertical-align:middle;<br>}<br>.parent::after{<br>    content:’’;<br>    height:100%;<br>}复制代码<br>这是一种很流行的方法, 也适应IE7.</p>
<h3 id="元素高度不定"><a href="#元素高度不定" class="headerlink" title="元素高度不定"></a>元素高度不定</h3><p>3) 可用 vertical-align 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle;</p>
<p>优点</p>
<p>元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断.</p>
<p>缺点</p>
<p>IE6~7, 甚至IE8 beta中无效.</p>
<p>4) 可用 Flex 2012版, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《弹性盒模型Flex指南》</p>
<p>父元素做如下设置即可保证子元素垂直居中:</p>
<p>.parent {<br>  display: flex;<br>  align-items: center;<br>}复制代码<br>优点</p>
<p>内容块的宽高任意, 优雅的溢出.<br>可用于更复杂高级的布局技术中.<br>缺点</p>
<p>IE8/IE9不支持<br>需要浏览器厂商前缀<br>渲染上可能会有一些问题<br>5) 使用flex 2009版.</p>
<p>.parent {<br>      display: box;<br>      box-orient: vertical;<br>      box-pack: center;<br>}复制代码<br>优点</p>
<p>实现简单, 扩展性强</p>
<p>缺点</p>
<p>兼容性差, 不支持IE</p>
<p>6) 可用 transform , 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<p>.son{<br>    position:absolute;<br>    top:50%;<br>    -webkit-transform: translate(-50%,-50%);<br>    -ms-transform: translate(-50%,-50%);<br>    transform: translate(-50%,-50%);<br>}复制代码<br>优点</p>
<p>代码量少</p>
<p>缺点</p>
<p>IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象.</p>
<p>元素高度固定<br>7) 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<p>.son{<br>    position:absolute;<br>    top:50%;<br>    height:固定;<br>    margin-top:-0.5高度;<br>}复制代码<br>优点</p>
<p>适用于所有浏览器.</p>
<p>缺点</p>
<p>父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条.</p>
<p>8) 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<p>.son{<br>    position:absolute;<br>    height:固定;<br>    top:0;<br>    bottom:0;<br>    margin:auto 0;<br>}复制代码<br>优点</p>
<p>简单</p>
<p>缺点</p>
<p>没有足够空间时, 子元素会被截断, 但不会有滚动条.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>水平居中较为简单, 共提供了8种方法, 一般情况下 text-align:center,marin:0 auto; 足矣</p>
<p>① text-align:center;<br>② margin:0 auto;<br>③ width:fit-content;<br>④ flex<br>⑤ 盒模型<br>⑥ transform<br>⑦ ⑧ 两种不同的绝对定位方法<br>垂直居中, 共提供了8种方法.</p>
<p>① 单行文本, line-height<br>② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现<br>③ vertical-align<br>④ flex<br>⑤ 盒模型<br>⑥ transform<br>⑦ ⑧ 两种不同的绝对定位方法<br>我们发现, flex, 盒模型, transform, 绝对定位, 这几种方法同时适用于水平居中和垂直居中.</p>
<h1 id="水平垂直居中实现"><a href="#水平垂直居中实现" class="headerlink" title="水平垂直居中实现"></a>水平垂直居中实现</h1><h2 id="仅居中元素定宽高适用："><a href="#仅居中元素定宽高适用：" class="headerlink" title="仅居中元素定宽高适用："></a>仅居中元素定宽高适用：</h2><ul>
<li><a href="http://yanhaijing.com/vertical-center/absolute1.html" target="_blank" rel="noopener">absolute + 负margin</a></li>
<li><a href="http://yanhaijing.com/vertical-center/absolute2.html" target="_blank" rel="noopener">absolute + margin auto</a></li>
<li><a href="http://yanhaijing.com/vertical-center/absolute3.html" target="_blank" rel="noopener">absolute + calc</a></li>
</ul>
<h2 id="居中元素不定宽高适用："><a href="#居中元素不定宽高适用：" class="headerlink" title="居中元素不定宽高适用："></a>居中元素不定宽高适用：</h2><ul>
<li><a href="http://yanhaijing.com/vertical-center/absolute4.html" target="_blank" rel="noopener">absolute + transform</a></li>
<li><a href="http://yanhaijing.com/vertical-center/writing-mode.html" target="_blank" rel="noopener">writing-mode</a></li>
<li><a href="http://yanhaijing.com/vertical-center/lineheight.html" target="_blank" rel="noopener">lineheight</a></li>
<li><a href="http://yanhaijing.com/vertical-center/table.html" target="_blank" rel="noopener">table</a></li>
<li><a href="http://yanhaijing.com/vertical-center/css-table.html" target="_blank" rel="noopener">css-table</a></li>
<li><a href="http://yanhaijing.com/vertical-center/flex.html" target="_blank" rel="noopener">flex</a></li>
<li><a href="http://yanhaijing.com/vertical-center/grid.html" target="_blank" rel="noopener">grid</a></li>
</ul>
<h2 id="absolute-负margin"><a href="#absolute-负margin" class="headerlink" title="absolute + 负margin"></a>absolute + 负margin</h2><p>为了实现上面的效果先来做些准备工作，假设HTML代码如下，总共两个元素，父元素和子元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>wp是父元素的类名，box是子元素的类名，因为有定宽和不定宽的区别，size用来表示指定宽度，下面是所有效果都要用到的公共代码，主要是设置颜色和宽高<br>注意：后面不在重复这段公共代码，只会给出相应提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 公共代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    background: green;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box.size&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">/* 公共代码 */</span><br></pre></td></tr></table></figure></p>
<p>绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的居中显示，但绝对定位是基于子元素的左上角，期望的效果是子元素的中心居中显示为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了，css代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">    margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是我比较常用的方式，这种方式比较好理解，兼容性也很好，缺点是<font color="red">需要知道子元素的宽高</font></p>
<h2 id="absolute-margin-auto"><a href="#absolute-margin-auto" class="headerlink" title="absolute + margin auto"></a>absolute + margin auto</h2><p>这种方式也要求居中元素的宽高必须固定，HTML代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法兼容性也很好，缺点是需要知道子元素的宽高</p>
<h2 id="absolute-calc"><a href="#absolute-calc" class="headerlink" title="absolute + calc"></a>absolute + calc</h2><p>这种方式也要求居中元素的宽高必须固定，所以我们为box增加size类，HTML代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>感谢css3带来了计算属性，既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;;</span><br><span class="line">    top: calc(50% - 50px);</span><br><span class="line">    left: calc(50% - 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法兼容性依赖calc的兼容性，缺点是需要知道子元素的宽高</p>
<h2 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h2><p>还是绝对定位，但这个方法不需要子元素固定宽高，所以不再需要size类了，HTML代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>修复绝对定位的问题，还可以使用css3新增的transform，transform的translate属性也可以设置百分比，其是相对于自身的宽和高，所以可以讲translate设置为-50%，就可以做到居中了，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法兼容性依赖translate2d的兼容性</p>
<h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h2><p>利用行内元素居中属性也可以做到水平垂直居中，HTML代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>把box设置为行内元素，通过text-align就可以做到水平居中，但很多同学可能不知道通过通过vertical-align也可以在垂直方向做到居中，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    line-height: 300px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: 0px;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    line-height: initial;</span><br><span class="line">    text-align: left; /* 修正文字 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法需要在子元素中将文字显示重置为想要的效果</p>
<h2 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h2><p>writing-mode可以改变文字的显示方向，比如可以通过writing-mode让文字的显示变为垂直方向<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;div1&quot;&gt;水平方向&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div2&quot;&gt;垂直方向&lt;/div&gt;</span><br><span class="line">.div2 &#123;</span><br><span class="line">    writing-mode: vertical-lr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">水平方向</span><br><span class="line">垂</span><br><span class="line">直</span><br><span class="line">方</span><br><span class="line">向</span><br></pre></td></tr></table></figure></p>
<p>更神奇的是所有水平方向上的css属性，都会变为垂直方向上的属性，比如text-align，通过writing-mode和text-align就可以做到水平和垂直方向的居中了，只不过要稍微麻烦一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;wp-inner&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">复制代码/* 此处引用上面的公共代码 */</span><br><span class="line">/* 此处引用上面的公共代码 */</span><br><span class="line"></span><br><span class="line">/* 定位代码 */</span><br><span class="line">.wp &#123;</span><br><span class="line">    writing-mode: vertical-lr;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.wp-inner &#123;</span><br><span class="line">    writing-mode: horizontal-tb;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    text-align: center;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin: auto;</span><br><span class="line">    text-align: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法实现起来和理解起来都稍微有些复杂</p>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>曾经table被用来做页面布局，现在没人这么做了，但table也能够实现水平垂直居中，但是会增加很多冗余代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td class=&quot;wp&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>
<p>tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.wp &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法就是代码太冗余，而且也不是table的正确用法</p>
<h2 id="css-table"><a href="#css-table" class="headerlink" title="css-table"></a>css-table</h2><p>css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面通过css属性，可以让div显示的和table一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wp &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    text-align: center;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复制代码这种方法和table一样的原理，但却没有那么多冗余代码，兼容性也还不错</p>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex作为现代的布局方案，颠覆了过去的经验，只需几行代码就可以优雅的做到水平垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.wp &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前在移动端已经完全可以使用flex了，PC端需要看自己业务的兼容性情况</p>
<h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><p>css新出的网格布局，由于兼容性不太好，一直没太关注，通过grid也可以实现水平垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wp&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.wp &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    align-self: center;</span><br><span class="line">    justify-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码量也很少，但兼容性不如flex，不推荐使用</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>下面对比下各个方式的优缺点，肯定又双叒叕该有同学说回字的写法了，简单总结下</p>
<ul>
<li>PC端有兼容性要求，宽高固定，推荐absolute + 负margin</li>
<li>PC端有兼容要求，宽高不固定，推荐css-table</li>
<li>PC端无兼容性要求，推荐flex</li>
<li>移动端推荐使用flex</li>
</ul>
<p><strong>小贴士：</strong>关于flex的兼容性决方案，请看这里《<a href="//yanhaijing.com/css/2016/08/21/flex-practice-on-mobile/">移动端flex布局实战</a>》</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>居中元素定宽高固定</th>
<th>PC兼容性</th>
<th>移动端兼容性</th>
</tr>
</thead>
<tbody>
<tr>
<td>absolute + 负margin</td>
<td>是</td>
<td>ie6+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>absolute + margin auto</td>
<td>是</td>
<td>ie6+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>absolute + calc</td>
<td>是</td>
<td>ie9+, chrome19+, firefox4+</td>
<td>安卓4.4+, iOS6+</td>
</tr>
<tr>
<td>absolute + transform</td>
<td>否</td>
<td>ie9+, chrome4+, firefox3.5+</td>
<td>安卓3+, iOS6+</td>
</tr>
<tr>
<td>writing-mode</td>
<td>否</td>
<td>ie6+, chrome4+, firefox3.5+</td>
<td>安卓2.3+, iOS5.1+</td>
</tr>
<tr>
<td>lineheight</td>
<td>否</td>
<td>ie6+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>table</td>
<td>否</td>
<td>ie6+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>css-table</td>
<td>否</td>
<td>ie8+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>flex</td>
<td>否</td>
<td>ie10+, chrome4+, firefox2+</td>
<td>安卓2.3+, iOS6+</td>
</tr>
<tr>
<td>grid</td>
<td>否</td>
<td>ie10+, chrome57+, firefox52+</td>
<td>安卓6+, iOS10.3+</td>
</tr>
</tbody>
</table>

                
                <div class="readmore">
                    <a href="/2019/01/05/垂直居中/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/04/盒模型/">
                        盒模型
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-04T08:40:34.000Z">
                            2019-01-04
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h1><p>简介：就是用来装页面上的元素的矩形区域。CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。</p>
<p>box-sizing(有3个值哦)：border-box,padding-box,content-box.</p>
<p>标准盒子模型：<br><img src="/2019/01/04/盒模型/box1.png" alt=""><br>IE盒子模型：<br><img src="/2019/01/04/盒模型/box2.png" alt=""><br>区别：从图中我们可以看出，这两种盒子模型最主要的区别就是width的包含范围，在标准的盒子模型中，width指content部分的宽度，在IE盒子模型中，width表示content+padding+border这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：</p>
<p>标准盒子模型的盒子宽度：左右border+左右padding+width<br>IE盒子模型的盒子宽度：width</p>
<p>在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型</p>
<p>最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右padding+width</p>

                
                <div class="readmore">
                    <a href="/2019/01/04/盒模型/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/03/面试JS/">
                        面试JS
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-03T13:42:31.000Z">
                            2019-01-03
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="介绍一下JS的数据类型？"><a href="#介绍一下JS的数据类型？" class="headerlink" title="介绍一下JS的数据类型？"></a>介绍一下JS的数据类型？</h1><blockquote>
<p>简单类型：String、Number、Boolean、Null、Undefined<br>复杂类型：ObjectES6新增类型：Symbol<br>扩展：null与undefined有什么区别 </p>
</blockquote>
<p>答：null 表示一个对象被定义了，值为“空值”，而undefined 表示不存在这个值。 正因为这个原因，所以使用typeof判断时，null返回的是object，而undefined返回的是undefined。(判断两者时需要使用===严格判断)<br>Boolean类型在进行判断的时候设置为 0、-0、null、””、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 “false”）</p>
<h1 id="如何通过JS判断一个数组？"><a href="#如何通过JS判断一个数组？" class="headerlink" title="如何通过JS判断一个数组？"></a>如何通过JS判断一个数组？</h1><blockquote>
<p>1.instanceof方法</p>
</blockquote>
<p>instanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = []; </span><br><span class="line">arr instanceof Array; // true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.constructor方法</p>
</blockquote>
<p>constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = []; </span><br><span class="line">arr.constructor == Array; //true</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>3.特性判断法</p>
</blockquote>
<p>利用判断数组独有的length和splice方法，但是这是不靠谱的，因为对象也能添加方法和属性。那怎么办了，有一个办法，可以利用数组的length属性没法枚举来判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function isArray(object)&#123;</span><br><span class="line">      return  object &amp;&amp; typeof object===&apos;object&apos; &amp;&amp;    </span><br><span class="line">      typeof object.length===&apos;number&apos; &amp;&amp;  </span><br><span class="line">      typeof object.splice===&apos;function&apos; &amp;&amp;    </span><br><span class="line">       //判断length属性是否是可枚举的 对于数组 将得到false  </span><br><span class="line">      !(object.propertyIsEnumerable(&apos;length&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>4.最简单的方法</p>
</blockquote>
<p>这种写法，是 jQuery 正在使用的，淘宝的 kissy 也是使用这种方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(value) == &apos;[object Array]&apos;</span><br><span class="line">// 利用这个方法，可以写一个返回数据类型的方法</span><br><span class="line">var isType = function (obj) &#123;</span><br><span class="line">     return Object.prototype.toString.call(obj).slice(8,-1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>5.ES5新增方法isArray()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array(123);</span><br><span class="line">var b = new Date();</span><br><span class="line">console.log(Array.isArray(a)); //true</span><br><span class="line">console.log(Array.isArray(b)); //false</span><br></pre></td></tr></table></figure>
<p>&amp;扩展：<br>使用instanceof和construcor，被判断的array必须是在当前页面声明的。比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false。<br>最简单的方法，在IE6下判断null和undefined，有一些bug，判断undefined和null均为Object，(并不是bug，是在ES3的标准下返回的就为Object)</p>
<h1 id="谈一谈let、const与var的区别？"><a href="#谈一谈let、const与var的区别？" class="headerlink" title="谈一谈let、const与var的区别？"></a>谈一谈let、const与var的区别？</h1><h2 id="let命令基本用法"><a href="#let命令基本用法" class="headerlink" title="let命令基本用法"></a>let命令基本用法</h2><p>在ES6中，新增了let命令，用于声明变量，用来取代ES5中var命令，消除var声明的变量的不合理，不严谨之处。const用于声明常量。<br>让我们来看看let和var的区别</p>
<blockquote>
<p>1.let不存在变量提升</p>
</blockquote>
<p>使用let声明的变量，不会像使用var那样存在“变量提升“”的现象。所以使用let声明变量，必须遵循“先声明，后使用”的原则。否则会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); //ReferenceError</span><br><span class="line">let a = 10;</span><br></pre></td></tr></table></figure></p>
<p>如果是var声明的变量，则不会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(b); //undefined</span><br><span class="line">var b = 10;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>2.let声明的变量，存在块级作用域</p>
</blockquote>
<p>let声明的变量只在所声明的代码块内有效。块级作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    var a = 10;</span><br><span class="line">    let b = 20;  </span><br><span class="line">&#125;</span><br><span class="line">    console.log(a); //10</span><br><span class="line">    console.log(b); // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a =[];</span><br><span class="line">for( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    a[i] = function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    for( var j = 0; j&lt;a.length; j++ )&#123;</span><br><span class="line">        a[j](); //输出10个10。 因为i是var声明的，在全局范围内都用，每次新的i都会覆盖原来的。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a =[];</span><br><span class="line">    for( let i=0; i&lt;10; i++ )&#123;</span><br><span class="line">        a[i] = function()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for( let j = 0; j&lt;a.length; j++ )&#123;</span><br><span class="line">        a[j](); //输出 0，1，2，...，9</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.let不允许在同一作用域内重复声明同一个变量在同一作用域内，如果使用var声明同一个变量，则后面的覆盖前面的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">let a = 10;</span><br><span class="line"></span><br><span class="line">console.log(a);//Uncaught SyntaxError:</span><br><span class="line">                 Identifier &apos;a&apos; has already been declared</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">let a = 10;</span><br><span class="line">let a = 15;</span><br><span class="line"></span><br><span class="line">console.log(a);//Uncaught SyntaxError:</span><br><span class="line">                 Identifier &apos;a&apos; has already been declared</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.暂时性死区：在代码块内，使用let声明变量之前，该变量都是不可以使用用<br>只要在同一作用域内存在let命令，他所声明的变量就“绑定”在这个作用域内，不管外部有没有声明</p>
</blockquote>
<p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a =10;</span><br><span class="line">function fn1()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    let a = 5;</span><br><span class="line">&#125;</span><br><span class="line">fn1();//Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p>
<p>ES6规定，如果在区块中存在let和const声明的变量，则这个区块对这些声明的变量从一开始就形成一个封闭的作用域。不管在外部有没有声明这个变量。必须遵守“先声明，后使用”的原则，否则报错</p>
<p>ES6规定暂时性死区和不存在变量提升，主要是为了减少运行程序的错误，防止出现“先使用（变量），后声明（变量）”的情况，从而导致意料之外的行为。这种错误在ES5中很常见，现在有了这种规定，就可以避免出现此类错误了</p>
<font color="red">总之，暂时性死区的本质就是，只要一进入当前作用域，所使用的变量就已存在，但是不可获取，只有等到声明变量的哪一行代码的出现，在可以获取和使用该变量</font>

<h2 id="const命令的基本使用"><a href="#const命令的基本使用" class="headerlink" title="const命令的基本使用"></a>const命令的基本使用</h2><p>const用来声明常量，一旦声明，其值就不能更改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = 10;</span><br><span class="line">    a = 20;</span><br><span class="line"></span><br><span class="line"> console.log(a);//Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>1.const声明的常量不能改变，意味着const一旦声明常量，就必须同时初始化。不能先声明，后初始化，这样会报错</p>
</li>
<li><p>2.与let一样。const声明的常量也只在块级作用域内有效 </p>
</li>
<li>3.与let一样，必须先声明，后使用 </li>
<li>4.与let一样，在同一作用域，const不能重复声明同一常量</li>
</ul>
<p>那么如果使用const声明对象呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const b = &#123;</span><br><span class="line">        name:&apos;zs&apos;,</span><br><span class="line">        age:22</span><br><span class="line">    &#125;</span><br><span class="line">b.name = &quot;lzx&quot;;</span><br><span class="line"></span><br><span class="line">console.log(b.name+&quot;---&quot;+b.age);//输出lzx---22</span><br></pre></td></tr></table></figure></p>
<p><font color="red">我们可以看到，使用const声明的对象的属性是可以修改。 </font><br>因为Object类型是引用类型。用const声明常量保存的是对象的地址，不可变的是地址，在上面的代码中就是，不能把 b 指向另一个对象。而修改对象的属性，并不会改变对象的地址，因此用const声明对象的属性是可以修改的 </p>
<h1 id="map与forEach的区别？"><a href="#map与forEach的区别？" class="headerlink" title="map与forEach的区别？"></a>map与forEach的区别？</h1><p>1、forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item、数组索引index、和当前遍历数组Array。另外，除去第一个必须的回调函数参数，还可以接受一个上下文参数(改变回调函数的this指向)；并且forEach不会遍历空元素。<br>2、map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined。(从字面理解，map就是映射的意思)<br>3、filter方法，用法和map很相似，从字面理解，就是过滤、筛选的意思。但是函数的callback需要返回布尔值true或false，并且返回值只需要为弱等==即可。<br>4、some 方法，对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。(一旦遇到true，就会中断循环，返回true，类似于||判断)<br>5、every方法，对数组中的每一项运行给定函数，如果该函数对每一项返回true，则返回true。(一旦遇到false，就会中断循环，返回false，类似于&amp;&amp;判断)<br>6、indexOf方法，与字符串中的indexOf类似，返回数组索引值，如果没有匹配，则会返回-1，第二个参数为可选，表示从当前位置开始搜索。<br>7、lastIndexOf方法，与indexOf相似，只是是从数组的末尾开始查找，而第二个参数的默认值是array.length - 1。<br>8、reduce方法，字面意思应该是‘减少’，但是实际是‘递归’的意思。实际就是应用一个函数针对数组的两个值(从左到右)，以减至一个值。它的callback接收4个参数：之前值(上一次循环返回的值)、当前值、索引值以及数组本身。initialValue参数可选，表示初始值。<br>9、reduceRight方法，与reduce方法类似，只是从数组的末尾开始实现。</p>
<h1 id="谈一谈你理解的函数式编程？"><a href="#谈一谈你理解的函数式编程？" class="headerlink" title="谈一谈你理解的函数式编程？"></a>谈一谈你理解的函数式编程？</h1><h1 id="谈一谈箭头函数与普通函数的区别？"><a href="#谈一谈箭头函数与普通函数的区别？" class="headerlink" title="谈一谈箭头函数与普通函数的区别？"></a>谈一谈箭头函数与普通函数的区别？</h1><ul>
<li>箭头函数使得表达更加简洁。(这个是废话)</li>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
<h1 id="谈一谈函数中this的指向吧？"><a href="#谈一谈函数中this的指向吧？" class="headerlink" title="谈一谈函数中this的指向吧？"></a>谈一谈函数中this的指向吧？</h1><h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><blockquote>
<p>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指代全局对象。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在浏览器中, window 对象同时也是全局对象：</span><br><span class="line">console.log(this === window); // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">a = 37;</span><br><span class="line">console.log(window.a); // 37</span><br><span class="line"></span><br><span class="line">this.b = <span class="string">"MDN"</span>;</span><br><span class="line">console.log(window.b)  // <span class="string">"MDN"</span></span><br><span class="line">console.log(b)         // <span class="string">"MDN"</span></span><br></pre></td></tr></table></figure>
<h2 id="函数（运行内）环境"><a href="#函数（运行内）环境" class="headerlink" title="函数（运行内）环境"></a>函数（运行内）环境</h2><p>在函数内部，this的值取决于函数被调用的方式。</p>
<h3 id="简单调用"><a href="#简单调用" class="headerlink" title="简单调用"></a>简单调用</h3><p>因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">//在浏览器中：</span><br><span class="line">f1() === window;   //在浏览器中，全局对象是window</span><br><span class="line"></span><br><span class="line">//在Node中：</span><br><span class="line">f1() === global;</span><br></pre></td></tr></table></figure></p>
<p>然而，在严格模式下，this将保持他进入执行环境时的值，所以下面的this将会默认为undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">  <span class="string">"use strict"</span>; // 这里是严格模式</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === undefined; // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>所以，在严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined。</p>
<blockquote>
<p>在第二个例子中，this的确应该是undefined，因为f2是被直接调用的，而不是作为对象的属性或方法调用的（如 window.f2()）。有一些浏览器最初在支持严格模式时没有正确实现这个功能，于是它们错误地返回了window对象。</p>
</blockquote>
<p>如果要想把 this 的值从一个环境传到另一个，就要用 call 或者apply 方法<br>// 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: <span class="string">'Custom'</span>&#125;;</span><br><span class="line"></span><br><span class="line">// 这个属性是在global对象定义的。</span><br><span class="line">var a = <span class="string">'Global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> whatsThis(arg) &#123;</span><br><span class="line">  <span class="built_in">return</span> this.a;  // this的值取决于函数的调用方式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whatsThis();          // <span class="string">'Global'</span></span><br><span class="line">whatsThis.call(obj);  // <span class="string">'Custom'</span></span><br><span class="line">whatsThis.apply(obj); // <span class="string">'Custom'</span></span><br></pre></td></tr></table></figure></p>
<p>当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(c, d) &#123;</span><br><span class="line">  <span class="built_in">return</span> this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;a: 1, b: 3&#125;;</span><br><span class="line"></span><br><span class="line">// 第一个参数是作为‘this’使用的对象</span><br><span class="line">// 后续参数作为参数传递给函数调用</span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line"></span><br><span class="line">// 第一个参数也是作为‘this’使用的对象</span><br><span class="line">// 第二个参数是一个数组，数组里的元素用作函数调用中的参数</span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br></pre></td></tr></table></figure></p>
<p>使用 call 和 apply 函数的时候要注意，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。因此，如果传递的值是一个原始值比如 7 或 ‘foo’，那么就会使用相关构造函数将它转换为对象，所以原始值 7 会被转换为对象，像 new Number(7) 这样，而字符串 ‘foo’ 转化成 new String(‘foo’) 这样，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  console.log(Object.prototype.toString.call(this));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原始值 7 被隐式转换为对象</span><br><span class="line">bar.call(7); // [object Number]</span><br></pre></td></tr></table></figure></p>
<h3 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h3><p>ECMAScript 5 引入了 Function.prototype.bind。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f.bind(&#123;a:<span class="string">"azerty"</span>&#125;);</span><br><span class="line">console.log(g()); // azerty</span><br><span class="line"></span><br><span class="line">var h = g.bind(&#123;a:<span class="string">'yoo'</span>&#125;); // <span class="built_in">bind</span>只生效一次！</span><br><span class="line">console.log(h()); // azerty</span><br><span class="line"></span><br><span class="line">var o = &#123;a:37, f:f, g:g, h:h&#125;;</span><br><span class="line">console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty</span><br></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数详解1</a><br>  <a href="https://www.cnblogs.com/freelyflying/p/6978126.html" target="_blank" rel="noopener">箭头函数详解2</a></p>
<p>在箭头函数中，this与封闭词法环境的this保持一致。在全局代码中，它将被设置为全局对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var globalObject = this;</span><br><span class="line">var foo = (() =&gt; this);</span><br><span class="line">console.log(foo() === globalObject); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：如果将this传递给call、bind、或者apply，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为null。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 接着上面的代码</span><br><span class="line">// 作为对象的一个方法调用</span><br><span class="line">var obj = &#123;foo: foo&#125;;</span><br><span class="line">console.log(obj.foo() === globalObject); // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 尝试使用call来设定this</span><br><span class="line">console.log(foo.call(obj) === globalObject); // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 尝试使用<span class="built_in">bind</span>来设定this</span><br><span class="line">foo = foo.bind(obj);</span><br><span class="line">console.log(foo() === globalObject); // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>无论如何，foo 的 this 被设置为他被创建时的环境（在上面的例子中，就是全局对象）。这同样适用于在其他函数内创建的箭头函数：这些箭头函数的this被设置为封闭的词法环境的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个含有bar方法的obj对象，</span><br><span class="line">// bar返回一个函数，</span><br><span class="line">// 这个函数返回this，</span><br><span class="line">// 这个返回的函数是以箭头函数创建的，</span><br><span class="line">// 所以它的this被永久绑定到了它外层函数的this。</span><br><span class="line">// bar的值可以在调用中设置，这反过来又设置了返回函数的值。</span><br><span class="line">var obj = &#123;</span><br><span class="line">  bar: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var x = (() =&gt; this);</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。</span><br><span class="line">// 将返回的函数的引用赋值给fn。</span><br><span class="line">var fn = obj.bar();</span><br><span class="line"></span><br><span class="line">// 直接调用fn而不设置this，</span><br><span class="line">// 通常(即不使用箭头函数的情况)默认为全局对象</span><br><span class="line">// 若在严格模式则为undefined</span><br><span class="line">console.log(fn() === obj); // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 但是注意，如果你只是引用obj的方法，</span><br><span class="line">// 而没有调用它</span><br><span class="line">var fn2 = obj.bar;</span><br><span class="line">// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。</span><br><span class="line">console.log(fn2()() == window); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，一个赋值给了 obj.bar的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 A 调用时，函数B的this被永久设置为obj.bar（函数A）的this。当返回的函数（函数B）被调用时，它this始终是最初设置的。在上面的代码示例中，函数B的this被设置为函数A的this，即obj，所以即使被调用的方式通常将其设置为 undefined 或全局对象（或者如前面示例中的其他全局执行环境中的方法），它的 this 也仍然是 obj .</p>
<h3 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h3><p>当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。<br>下面的例子中，当 o.f()被调用时，函数内的this将绑定到o对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); // logs 37</span><br></pre></td></tr></table></figure></p>
<p>请注意，这样的行为，根本不受函数定义方式或位置的影响。在前面的例子中，我们在定义对象o的同时，将函数内联定义为成员f。但是，我们也可以先定义函数，然后再将其附属到o.f。这样做会导致相同的行为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">independent</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f = independent;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); // logs 37</span><br></pre></td></tr></table></figure></p>
<p>这表明函数是从o的f成员调用的才是重点。</p>
<p>同样，this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法g当作对象o.b的函数调用。在这次执行期间，函数中的this将指向o.b。事实证明，这与他是对象 o 的成员没有多大关系，最靠近的引用才是最重要的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.b = &#123;g: independent, prop: 42&#125;;</span><br><span class="line">console.log(o.b.g()); // 42</span><br></pre></td></tr></table></figure></p>
<h3 id="原型链中的-this"><a href="#原型链中的-this" class="headerlink" title="原型链中的 this"></a>原型链中的 this</h3><p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f: <span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">    <span class="built_in">return</span> this.a + this.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p = Object.create(o);</span><br><span class="line">p.a = 1;</span><br><span class="line">p.b = 4;</span><br><span class="line"></span><br><span class="line">console.log(p.f()); // 5</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，对象p没有属于它自己的f属性，它的f属性继承自它的原型。虽然在对 f 的查找过程中，最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向p。也就是说，因为f是作为p的方法调用的，所以它的this指向了p。这是 JavaScript 的原型继承中的一个有趣的特性。</p>
<h3 id="getter-与-setter-中的-this"><a href="#getter-与-setter-中的-this" class="headerlink" title="getter 与 setter 中的 this"></a>getter 与 setter 中的 this</h3><p>再次，相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.a + this.b + this.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3,</span><br><span class="line">  get <span class="function"><span class="title">average</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (this.a + this.b + this.c) / 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o, <span class="string">'sum'</span>, &#123;</span><br><span class="line">    get: sum, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">console.log(o.average, o.sum); // logs 2, 6</span><br></pre></td></tr></table></figure></p>
<h3 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h3><p>当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象</p>
<blockquote>
<p>虽然构造器返回的默认值是this所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回this对象）。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 构造函数这样工作:</span><br><span class="line"> *</span><br><span class="line"> * <span class="keyword">function</span> <span class="function"><span class="title">MyConstructor</span></span>()&#123;</span><br><span class="line"> *   // 函数实体写在这里</span><br><span class="line"> *   // 根据需要在this上创建属性，然后赋值给它们，比如：</span><br><span class="line"> *   this.fum = <span class="string">"nom"</span>;</span><br><span class="line"> *   // 等等...</span><br><span class="line"> *</span><br><span class="line"> *   // 如果函数具有返回对象的<span class="built_in">return</span>语句，</span><br><span class="line"> *   // 则该对象将是 new 表达式的结果。 </span><br><span class="line"> *   // 否则，表达式的结果是当前绑定到 this 的对象。</span><br><span class="line"> *   //（即通常看到的常见情况）。</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">C</span></span>()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = new C();</span><br><span class="line">console.log(o.a); // logs 37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">C2</span></span>()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  <span class="built_in">return</span> &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = new C2();</span><br><span class="line">console.log(o.a); // logs 38</span><br></pre></td></tr></table></figure>
<h3 id="作为一个DOM事件处理函数节"><a href="#作为一个DOM事件处理函数节" class="headerlink" title="作为一个DOM事件处理函数节"></a>作为一个DOM事件处理函数节</h3><p>当函数被用作事件处理函数时，它的this指向触发事件的元素（一些浏览器在使用非addEventListener的函数动态添加监听函数时不遵守这个约定）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 被调用时，将关联的元素变成蓝色</span><br><span class="line"><span class="keyword">function</span> bluify(e)&#123;</span><br><span class="line">  console.log(this === e.currentTarget); // 总是 <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  // 当 currentTarget 和 target 是同一个对象时为 <span class="literal">true</span></span><br><span class="line">  console.log(this === e.target);        </span><br><span class="line">  this.style.backgroundColor = <span class="string">'#A5D9F3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取文档中的所有元素的列表</span><br><span class="line">var elements = document.getElementsByTagName(<span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line"><span class="keyword">for</span>(var i=0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">  elements[i].addEventListener(<span class="string">'click'</span>, bluify, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="作为一个内联事件处理函数"><a href="#作为一个内联事件处理函数" class="headerlink" title="作为一个内联事件处理函数"></a>作为一个内联事件处理函数</h3><p>当代码被内联on-event 处理函数调用时，它的this指向监听器所在的DOM元素：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span><br><span class="line">  Show this</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面的 alert 会显示button。注意只有外层代码中的this是这样设置的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span><br><span class="line">  Show inner this</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，没有设置内部函数的this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置this时指向的默认对象）</p>
<h1 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h1><p>回调函数：<br>优点：简单、容易理解<br>缺点：不利于维护，代码耦合高</p>
<blockquote>
<p>1.事件监听(采用时间驱动模式，取决于某个事件是否发生)：</p>
</blockquote>
<p>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数<br>缺点：事件驱动型，流程不够清晰</p>
<blockquote>
<p>2.发布/订阅(观察者模式)：</p>
</blockquote>
<p>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者。</p>
<blockquote>
<p>3.Promise对象</p>
</blockquote>
<p>优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；<br>缺点：编写和理解，相对比较难</p>
<blockquote>
<p>4.Generator函数</p>
</blockquote>
<p>优点：函数体内外的数据交换、错误处理机制<br>缺点：流程管理不方便</p>
<blockquote>
<p>5.async函数</p>
</blockquote>
<p>优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。<br>缺点：错误处理机制</p>
<p>……js基础</p>
<p>类和继承（es5实现方法 + es6实现方法）；</p>
<p>promise；</p>
<p>写一个方法遍历所有文档树所有节点(考察递归)；</p>
<p>jsonp和跨域；</p>
<p>sort排序相关(注意ascll这个坑)</p>
<p>数组和对象的深浅拷贝；</p>
<p>String + Array的一些基本操作；<br>写一个数组去重的方法；<br>冒泡和捕获；<br>事件代理；</p>
<p>call、apply、bind；<br>变量提升；<br>高阶函数；<br>动画；<br>setTimeout、setInterval和requestAnimationFrame；<br>模块化开发；<br>引起内存泄漏的原因；<br>ajax；<br>map、filter、reduce相关；<br>Map和Set；<br>移动端开发相关；</p>
<p>……技术拓展</p>
<p>设计模式相关(单例、发布订阅等)；<br>浏览器渲染过程；<br>性能优化相关(这个点很大，设计很多方面，不要自以为优化就是网上经常看到的那一套)；<br>设计一个模版引擎；<br>设计一个打包工具；<br>设计一个mvvm框架需要注意的case；<br>源码阅读相关；</p>
<p>作者：玩弄心里的鬼<br>链接：<a href="https://juejin.im/post/59ec3d50f265da431c6f7339" target="_blank" rel="noopener">https://juejin.im/post/59ec3d50f265da431c6f7339</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="json的JSON-parse-和JSON-stringfy"><a href="#json的JSON-parse-和JSON-stringfy" class="headerlink" title="json的JSON.parse()和JSON.stringfy()"></a>json的JSON.parse()和JSON.stringfy()</h1><h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><blockquote>
<p>从字符串解析出对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义一个字符串</span><br><span class="line">var data=&apos;&#123;&quot;name&quot;:&quot;goatling&quot;&#125;&apos;</span><br><span class="line">//解析对象​</span><br><span class="line">​JSON.parse(data)</span><br><span class="line">结果是：</span><br><span class="line">​name:&quot;goatling&quot;</span><br></pre></td></tr></table></figure>
<h2 id="JSON-stringfy"><a href="#JSON-stringfy" class="headerlink" title="JSON.stringfy()"></a>JSON.stringfy()</h2><blockquote>
<p>从一个对象解析出字符串</p>
</blockquote>
<pre><code>var data={name:&apos;goatling&apos;}
JSON.stringify(data)
结果是：
&apos;{&quot;name&quot;:&quot;goatling&quot;}&apos;
</code></pre>
                
                <div class="readmore">
                    <a href="/2019/01/03/面试JS/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/02/闭包/">
                        闭包
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-02T02:54:13.000Z">
                            2019-01-02
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包理解"><a href="#闭包理解" class="headerlink" title="闭包理解"></a>闭包理解</h2><h3 id="特性："><a href="#特性：" class="headerlink" title="** 特性："></a>** 特性：</h3><p>函数嵌套函数；<br>函数内部可以引用函数外部的参数和变量；<br>函数变量和参数不会被垃圾回收机制回收；</p>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="**优缺点："></a>**优缺点：</h3><p>优点 </p>
<ul>
<li>希望一个变量长期驻扎在内存中 </li>
<li>避免全局变量的污染 </li>
<li>私有成员的存在<br>缺点 </li>
<li>常驻内存，增大内存使用量，使用不当回造成内存泄漏；</li>
</ul>
<h3 id="自执行函数的好处"><a href="#自执行函数的好处" class="headerlink" title="** 自执行函数的好处"></a>** 自执行函数的好处</h3><p>隔离作用域，避免全局作用域污染<br>模拟块级作用域</p>
<p>应用的两种情况：函数作为返回值、函数作为参数传递。</p>
<h3 id="第一，函数作为返回值："><a href="#第一，函数作为返回值：" class="headerlink" title="第一，函数作为返回值："></a>第一，函数作为返回值：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>()&#123;</span><br><span class="line">    var max = 10;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> bar(x)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&gt;max)&#123;</span><br><span class="line">            console.log(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f1 = fn();</span><br><span class="line">f1(15);</span><br></pre></td></tr></table></figure>
<p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值</p>
<h3 id="第二，函数作为参数被传递"><a href="#第二，函数作为参数被传递" class="headerlink" title="第二，函数作为参数被传递"></a>第二，函数作为参数被传递</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var max = 10,</span><br><span class="line">fn = <span class="keyword">function</span>(x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;max)&#123;</span><br><span class="line">        console.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="keyword">function</span>(f)&#123;</span><br><span class="line">    var max = 100;</span><br><span class="line">    f(15);</span><br><span class="line">&#125;)(fn)</span><br></pre></td></tr></table></figure>
<p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p>
<h2 id="闭包与作用域"><a href="#闭包与作用域" class="headerlink" title="闭包与作用域"></a>闭包与作用域</h2><h3 id="变量的作用域-是指变量的有效范围"><a href="#变量的作用域-是指变量的有效范围" class="headerlink" title="变量的作用域,是指变量的有效范围"></a>变量的作用域,是指变量的有效范围</h3><p>当在函数中声明一个变量的时候,如果该变量前面没有带上关键字 var,这个变量就会成为全局变量 ,这当然是一种很容易造成命名冲突的做法。<br>另外一种情况是用 var 关键字在函数中声明变量,这时候的变量即是局部变量,只有在该函数内部才能访问到这个变量,在函数外面是访问不到的。</p>
<p>例一<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var func=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var a=1;</span><br><span class="line">    console.log(a); //输出:1 </span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br><span class="line">console.log ( a ); // Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p>
<p>例二，变量的搜索是从内到外而非从外到 内的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a=1;</span><br><span class="line">var func1 = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">    var b=2;</span><br><span class="line">    var func2 = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">        var c=3;</span><br><span class="line">        console.log ( b ); // 输出:2 </span><br><span class="line">        console.log ( a );// 输出:1</span><br><span class="line">    &#125;</span><br><span class="line">    func2();</span><br><span class="line">    console.log(c);//输出:Uncaught ReferenceError: c is not defined</span><br><span class="line">&#125;; </span><br><span class="line">func1();</span><br></pre></td></tr></table></figure></p>
<h3 id="变量的生存周期。"><a href="#变量的生存周期。" class="headerlink" title="变量的生存周期。"></a>变量的生存周期。</h3><p>对于全局变量来说,全局变量的生存周期当然是的永久,除非我们主动销毁这个全局变量。</p>
<p>而对于在函数内用 var 关键字声明的局部变量来说,当退出函数时,这些局部变量即失去了 它们的价值,它们都会随着函数的调用的结束而销毁</p>
<p>例一<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var func = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">    var a=1;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">        a++;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">var f=func();</span><br><span class="line">f();// 输出:2 </span><br><span class="line">f();// 输出:3</span><br><span class="line">f();// 输出:4</span><br><span class="line">f();// 输出:5</span><br></pre></td></tr></table></figure></p>
<p>跟我们之前的结论相反,上面的例子在当退出函数后,局部变量 a 并没有消失,而是似乎一直在某个地方 存活着。</p>
<p>这是因为当执行 var f = func();时,f 返回了一个名函数的引用,它可以问到 func() 被调用时产生的环境,而局部变量 a 一直处在这个环境里。</p>
<p>既然外局部变量所在的环境还能被外 界访问,这个局部变量就有了不被销毁的理由。在这里生了一个闭包结构,局部变量的声明看起来被延续了。</p>
<p>例二，假设页面上有 5 个 div 节点,我们通过循环来给每个 div绑定 onclick 事件,按照索引顺序,点击第 1 个 div 时弹出 0,点击第 2 个 div 时出 1,以此类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var nodes = document.getElementsByTagName( <span class="string">'div'</span> );</span><br><span class="line"><span class="keyword">for</span>(var i=0,len=nodes.length;i&amp;lt;len;i++)&#123; </span><br><span class="line">    nodes[ i ].onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>测试这段代码会发现,无论点击哪个 div,最后弹出的结果都是 5。</p>
<p><font color="red">这是因为 div 节点的 onclick事件是被异步触发的,当事件被触发的时候,for循环早已结束,此时 i 的值已经是 5,</font></p>
<p>所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时,查找到的值总是 5。</p>
<p>解决方法是在闭包的帮助下,每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链从内到外查找变量 i 时,会先找到被封闭在闭包环境中的 i,如果有 5 个 div,这里的 i 分别 是 0,1,2,3,4&gt;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i=0,len=nodes.length;i&amp;lt;len;i++)&#123; </span><br><span class="line">    (<span class="keyword">function</span>( i )&#123;</span><br><span class="line">        nodes[ i ].onclick = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>例三<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Type = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> ( var i = 0, <span class="built_in">type</span>; <span class="built_in">type</span> = [ <span class="string">'String'</span>, <span class="string">'Array'</span>, <span class="string">'Number'</span> ][ i++ ]; )&#123; </span><br><span class="line">    (<span class="keyword">function</span>( <span class="built_in">type</span> )&#123;</span><br><span class="line">        Type[ <span class="string">'is'</span> + <span class="built_in">type</span> ] = <span class="keyword">function</span>( obj )&#123;</span><br><span class="line">            <span class="built_in">return</span> Object.prototype.toString.call( obj ) === <span class="string">'[object '</span>+ <span class="built_in">type</span> +<span class="string">']'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)( <span class="built_in">type</span> )</span><br><span class="line">&#125;;</span><br><span class="line">console.log( Type.isArray( [] ) );// 输出:<span class="literal">true</span></span><br><span class="line">console.log( Type.isString( <span class="string">"str"</span> ) );// 输出:<span class="literal">true</span></span><br><span class="line">console.log( Type.isNumber( 5  ) );// 输出:<span class="literal">true</span></span><br><span class="line">console.log( Type.isString( [] ) );// 输出:<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/2019/01/02/闭包/1.png" alt=""><br><img src="/2019/01/02/闭包/2.png" alt=""><br><img src="/2019/01/02/闭包/3.png" alt=""><br><img src="/2019/01/02/闭包/4.png" alt=""><br><img src="/2019/01/02/闭包/5.png" alt=""></p>

                
                <div class="readmore">
                    <a href="/2019/01/02/闭包/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/02/遍历数组的常用方法/">
                        遍历数组的常用方法
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-02T02:18:07.000Z">
                            2019-01-02
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="遍历数组的常用方法"><a href="#遍历数组的常用方法" class="headerlink" title="遍历数组的常用方法"></a>遍历数组的常用方法</h1><h2 id="最传统方法-for循环"><a href="#最传统方法-for循环" class="headerlink" title="最传统方法 for循环"></a>最传统方法 for循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;,3,5,8];</span><br><span class="line">for(var i = 0; i &lt; arr.length;i++)&#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">    //输出：</span><br><span class="line">     first</span><br><span class="line">     second</span><br><span class="line">     third</span><br><span class="line">     fourth</span><br><span class="line">     3</span><br><span class="line">     5</span><br><span class="line">     8</span><br></pre></td></tr></table></figure>
<h2 id="for…-in"><a href="#for…-in" class="headerlink" title="for… in"></a>for… in</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">for(var i in arr)&#123;</span><br><span class="line">     console.log(arr[i] +&apos;/&apos; + i);</span><br><span class="line"> &#125;</span><br><span class="line"> //输出结果为：</span><br><span class="line">     first/0</span><br><span class="line">     second/1</span><br><span class="line">     third/2</span><br><span class="line">     fourth/3</span><br><span class="line">     3/4</span><br><span class="line">     5/5</span><br><span class="line">     8/6</span><br></pre></td></tr></table></figure>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">for(var item of arr)&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">//输出结果：</span><br><span class="line">    first</span><br><span class="line">    second</span><br><span class="line">    third</span><br><span class="line">    fourth</span><br><span class="line">    3</span><br><span class="line">    5</span><br><span class="line">    8</span><br></pre></td></tr></table></figure>
<p>虽然for… in 、for…of都能够变历数组，但是两者还是有很大区别的，先说结论：</p>
<blockquote>
<p>两者的主要区别在于：</p>
<ul>
<li>他们的迭代方式推荐在循环对象属性的时候，使用for in，在遍历数组的时候推荐使用for of</li>
<li>for…in 循环出来的是key, for…of循环出来的是value</li>
<li>for…in 是ES5 标准，for …of 是ES6标准，兼容性可能存在些问题，请注意使用</li>
<li>for…of 不能遍历普通的对象，需要和Object.keys()搭配使用。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">    //给数组添加新属性</span><br><span class="line">    arr.name = &apos;zhangsan&apos;;</span><br><span class="line">    for(var item of arr)&#123;</span><br><span class="line">        console.log(item);</span><br><span class="line">    &#125;</span><br><span class="line">    //输出：</span><br><span class="line">        first </span><br><span class="line">        second</span><br><span class="line">        third</span><br><span class="line">        fourth</span><br><span class="line">        3</span><br><span class="line">        5</span><br><span class="line">        8</span><br><span class="line">    console.log(&apos;--------------分隔符----------------&apos;);</span><br><span class="line">    for(var item in arr)&#123;</span><br><span class="line">        console.log(arr[item] + &apos;/&apos; + item);</span><br><span class="line">    &#125;</span><br><span class="line">    //输出：</span><br><span class="line">     first/0</span><br><span class="line">     second/1</span><br><span class="line">     third/2</span><br><span class="line">     fourth/3</span><br><span class="line">     3/4</span><br><span class="line">     5/5</span><br><span class="line">     8/6 </span><br><span class="line">     zhangsan/name</span><br></pre></td></tr></table></figure>
<p>循环除了遍历数组元素外，还会遍历自定义属性，for…of只可以循环可迭代的可迭代属性，不可迭代属性在循环中被忽略了</p>
<h2 id="foreach方法"><a href="#foreach方法" class="headerlink" title="foreach方法"></a>foreach方法</h2><p>被传递给foreach的函数会在数组的每个元素上执行一次，元素作为参数传递给该函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;,3,5,8];</span><br><span class="line">//element 表示arr的单元项，index 表示arr单元项对应的索引值</span><br><span class="line">arr.forEach(function(element,index)&#123;</span><br><span class="line">    console.log(element + &apos;/&apos; + index);</span><br><span class="line">&#125;)</span><br><span class="line">//输出结果：</span><br><span class="line">  first/0</span><br><span class="line">  second/1</span><br><span class="line">  third/2</span><br><span class="line">  fourth/3</span><br><span class="line">  3/4</span><br><span class="line">  5/5</span><br><span class="line">  8/6</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：未赋值的值是不会在foreach循环迭代的，但是手动赋值为undefined的元素是会被列出的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;first&quot;,&quot;second&quot;, ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">arr1.forEach(function(element,index)&#123;</span><br><span class="line">    console.log(element + &apos;/&apos; + index);</span><br><span class="line">&#125;)</span><br><span class="line">  //输出结果</span><br><span class="line">     first/0</span><br><span class="line">     second/1</span><br><span class="line">     fourth/3</span><br><span class="line">     3/4</span><br><span class="line">     5/5</span><br><span class="line">     8/6</span><br></pre></td></tr></table></figure>
<h2 id="map遍历数组"><a href="#map遍历数组" class="headerlink" title="map遍历数组"></a>map遍历数组</h2><p>并通过callback对数组元素进行操作，并将所有操作结果放入数组中并返回该数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;];</span><br><span class="line">var arr2 = arr.map(function(item,index,arr)&#123;</span><br><span class="line">   return item.toUpperCase();</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2);</span><br><span class="line">//输出：</span><br><span class="line">[FIRST,SECOND,THIRD, FOURTH]</span><br></pre></td></tr></table></figure></p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter( )"></a>filter( )</h2><p>返回一个包含所有在回调函数上返回为true的元素新数组，回调函数在此担任的是过滤器的角色,当元素符和条件，过滤器就返回true,而filter则会返回所有符合过滤条件的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">    var arr3 = arr.filter(function(item,index,arr)&#123;</span><br><span class="line">        if(typeof item == &apos;number&apos;)&#123;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(arr3);</span><br><span class="line">    //输出结果： </span><br><span class="line">    [3,5,8]</span><br></pre></td></tr></table></figure></p>
<h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><p>当数组中的每一个元素在callback上被返回true时就返回true注意：要求每一个单元项都返回true时才为true)<br>every()与filter()的区别是：后者会返回所有符合过滤条件的元素；前者会判断是不是数组中的所有元素都符合条件，并且返回的是布尔值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">var bol = arr.every(function(item, index, array)&#123;</span><br><span class="line">    if(typeof item == &apos;string&apos;)&#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> console.log(bol); //false</span><br></pre></td></tr></table></figure></p>
<h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><p>只要数组中有一项在callback上就返回true<br>every()与some()的区别是：前者要求所有元素都符合条件才返回true,后者要求只要有符合条件的就返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];</span><br><span class="line">    var bol = arr.some(function(item, index, array)&#123;</span><br><span class="line">        if(typeof item == &apos;string&apos;)&#123;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(bol); //true</span><br></pre></td></tr></table></figure></p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class="line"> return previousValue + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>reduce还有第二个参数，我们可以把这个参数作为第一次调用callback时的第一个参数，上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class="line"> return previousValue + currentValue;</span><br><span class="line">&#125;,5);</span><br></pre></td></tr></table></figure></p>
<p>第一次调用的previousValue的值就用传入的第二个参数代替</p>
<h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h2><p>reduceRight()方法的功能和reduce()功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。</p>
<h1 id="数组方法总结"><a href="#数组方法总结" class="headerlink" title="数组方法总结"></a>数组方法总结</h1><p>对于数组，最关心的的两个问题：返回值是什么，会不会对原始数组造成影响，典型的例子就是 splice 和 slice 方法。对于那些返回原数组的函数，我们可以直接调用数组的链式调用，array.filter().sort().reverse()。<br>下面用表格列出来所有方法的功能：<br><img src="/2019/01/02/遍历数组的常用方法/array01.png" alt=""><br>具体可参考：<a href="https://segmentfault.com/a/1190000008147878" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008147878</a></p>

                
                <div class="readmore">
                    <a href="/2019/01/02/遍历数组的常用方法/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/02/理解cookie、session、localStorage、sessionStorage之不同/">
                        理解cookie、session、localStorage、sessionStorage...
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-02T02:03:31.000Z">
                            2019-01-02
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="理解cookie、session、localStorage、sessionStorage之不同"><a href="#理解cookie、session、localStorage、sessionStorage之不同" class="headerlink" title="理解cookie、session、localStorage、sessionStorage之不同"></a>理解cookie、session、localStorage、sessionStorage之不同</h1><p><img src="http12.png" alt=""></p>
<ul>
<li><p>1、相同点：数据都保存在浏览器，同源共享。即相同的域下可以修改读取。</p>
</li>
<li><p>2、不同点：</p>
<p>   <font color="red">大小数量： </font>IE6或更低版本最多20个cookie，IE7+可以有50个。 cookie大小4KB左右，超过部分会被截掉。sessionStoage，localStoage大小可达5M。</p>
<p>   <font color="red">传输： </font>每次请求cookie都会发送到服务器，然后回传给浏览器，sessionStoage,localStoage不会自动发送到服务器端。</p>
<p> <font color="red">有效性：</font>cookie可以设置path路径，限制只属于某个路径。在过期时间之前都有效，即使窗口和浏览器关闭。sesesionStorage当前窗口有效，关闭窗口自动失效。localStorage始终有效，即使窗口和浏览器关闭。</p>
<p> <font color="red">作用域：</font>cookie在同源页面中共享，sessionStorage只能在当前页有效，localStorage在所有同源页面中共享。</p>
<p>  <font color="red">操作方法：</font>Cookie的修改读取方法需自己实现，sessionStorage，localStorage提供了get，set方法。    </p>
</li>
</ul>
<p>注：cookie是不可以或缺的，cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p>
<h1 id="web-Storage支持的属性与方法"><a href="#web-Storage支持的属性与方法" class="headerlink" title="web Storage支持的属性与方法"></a>web Storage支持的属性与方法</h1><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</p>
<p>getItem(key):获取指定key所存储的value值<br>key(index)方法：返回列表中对应索引的key值<br>length属性：返回key/value队列的长度<br>removeItem(key)方法：从Storage中删除一个对应的键值对。<br>setItem(key,value)方法：将value存储到key指定的字段。<br>clear()方法：移除所有的内容</p>

                
                <div class="readmore">
                    <a href="/2019/01/02/理解cookie、session、localStorage、sessionStorage之不同/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2019/01/01/跨域/">
                        跨域
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2019-01-01T14:00:08.000Z">
                            2019-01-01
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <p>jsonp跨域是通过动态添加script标签实现跨域的由于script标签只能发送get请求所以jsonp不支持post方式的跨域JSONP的最基本的原理是：动态添加一个<script>标签而script标签的src属性是没有跨域的限制的。这样说来，这种跨域方式其实与ajaxXmlHttpRequest协议无关了。可以说jsonp的方式原理上和&lt;scriptsrc=”http://跨域/…xx.js”&gt;</script>是一致的，因为他的原理实际上就是 使用js的script标签 进行传参，那么必然是get方式的了，和浏览器中敲入一个url一样</p>

                
                <div class="readmore">
                    <a href="/2019/01/01/跨域/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2018/12/27/http/">
                        http
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2018-12-27T13:35:13.000Z">
                            2018-12-27
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><ul>
<li><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</p>
</li>
<li><p>200 OK 正常返回信息</p>
</li>
<li><p>201 Created 请求成功并且服务器创建了新的资源</p>
</li>
<li><p>202 Accepted 服务器已接受请求，但尚未处理</p>
</li>
<li><p>301 Moved Permanently 请求的网页已永久移动到新位置。</p>
</li>
<li><p>302 Found 临时性重定向。</p>
</li>
<li><p>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</p>
</li>
<li><p>304 Not Modified 自从上次请求后，请求的网页未修改过。</p>
</li>
<li><p>Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</p>
</li>
<li><p>401 Unauthorized 请求未授权。</p>
</li>
<li><p>403 Forbidden 禁止访问。</p>
</li>
<li><p>404 Not Found 找不到如何与 URI 相匹配的资源。</p>
</li>
<li><p>500 Internal Server Error 最常见的服务器端错误。</p>
</li>
<li><p>503 Service Unavailable 服务器端暂时无法处理请求(可能是过载或维护)。</p>
</li>
</ul>

                
                <div class="readmore">
                    <a href="/2018/12/27/http/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2018/12/27/浏览器缓存/">
                        浏览器缓存
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2018-12-27T13:35:13.000Z">
                            2018-12-27
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h1 id="HTTP强缓存和协商缓存"><a href="#HTTP强缓存和协商缓存" class="headerlink" title="HTTP强缓存和协商缓存"></a>HTTP强缓存和协商缓存</h1><blockquote>
<p>浏览器缓存有下面的优点：</p>
<ul>
<li>减少冗余的数据传输</li>
<li>减少服务器负担</li>
<li>加快客户端加载网页的速度</li>
</ul>
</blockquote>
<p>在浏览器第一次发起请求时，本地无缓存，向web服务器发送请求，服务器起端响应请求，浏览器端缓存。过程如下：</p>
<p><center><img src="http01.png" alt=""></center><br>在第一次请求时，服务器会将页面最后修改时间通过Last-Modified标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个Etag，并发送给客户端。<br>浏览器后续再次进行请求时：</p>
<p><center><img src="http02.png" alt=""></center><br>浏览器缓存主要分为强强缓存（也称本地缓存）和协商缓存（也称弱缓存）。根据上图，浏览器在第一次请求发生后，再次发送请求时：</p>
<ul>
<li><p>浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的Cache-Control和Expires来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。后面会讲Cache-Control和Expires相关。</p>
</li>
<li><p>如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过If-None-Match头将先前服务器端发送过来的Etag发送给服务器，服务会对比这个客户端发过来的Etag是否与服务器的相同，若相同，就将If-None-Match的值设为false，返回状态304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将If-None-Match的值设为true，返回状态为200，客户端重新机械服务器端返回的数据；客户端还会通过If-Modified-Since头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。</p>
</li>
</ul>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存是利用http头中的Expires和Cache-Control两个字段来控制的，用来表示资源的缓存时间。强缓存中，普通刷新会忽略它，但不会清除它，需要强制刷新。浏览器强制刷新，请求会带上Cache-Control:no-cache和Pragma:no-cache</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。如我现在这个网页的Expires值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在Expires之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现Cache-Control:max-age和Expires，那么max-age优先级更高。如我主页的response headers部分如下：</p>
<p>cache-control:max-age=691200<br>expires:Fri, 14 Apr 2017 10:47:02 GMT<br>那么表示资源可以被缓存的最长时间为691200秒，会优先考虑max-age。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control是在http1.1中出现的，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：</p>
<p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p>
<p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p>
<p>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</p>
<p>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。<br>Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。</p>
<p>普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。</p>
<p>这个主要涉及到两组header字段：Etag和If-None-Match、Last-Modified和If-Modified-Since。上面以及说得很清楚这两组怎么使用啦~复习一下：</p>
<h3 id="Etag和If-None-Match"><a href="#Etag和If-None-Match" class="headerlink" title="Etag和If-None-Match"></a>Etag和If-None-Match</h3><p>Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。</p>
<p>与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</p>
<h3 id="Last-Modify-If-Modify-Since"><a href="#Last-Modify-If-Modify-Since" class="headerlink" title="Last-Modify/If-Modify-Since"></a>Last-Modify/If-Modify-Since</h3><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>
<p>当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p>
<p>如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。</p>
<p>为什么要有Etag<br>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p>
<p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p>
<p>某些服务器不能精确的得到文件的最后修改时间。</p>
<p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<h1 id="HTTP基于缓存策略三要素分解法"><a href="#HTTP基于缓存策略三要素分解法" class="headerlink" title="HTTP基于缓存策略三要素分解法"></a>HTTP基于缓存策略三要素分解法</h1><h2 id="两道题"><a href="#两道题" class="headerlink" title="两道题"></a>两道题</h2><p>以下为 page.html 内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;page页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><br><span class="line">&lt;img src=&quot;images/head.png&quot; /&gt;</span><br><span class="line">&lt;a href=&quot;page.html&quot;&gt;重新访问page页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>首次访问该页面，页面中 head.png 响应头信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p>
<p>问题1：请问当点击“重新访问 page 页”链接重新加载该页面后， head.png 如何二次加载？<br>问题2：如果将上述信息中的 Cache-Control 设置为 private，那么结果又会如何呢？</p>
<h2 id="HTTP缓存体系"><a href="#HTTP缓存体系" class="headerlink" title="HTTP缓存体系"></a>HTTP缓存体系</h2><p>首先我将 Http 缓存体系分为以下三个部分：<br><img src="http03.png" alt=""></p>
<h3 id="缓存存储策略"><a href="#缓存存储策略" class="headerlink" title="缓存存储策略"></a>缓存存储策略</h3><blockquote>
<p>用来确定 Http响应内容是否可以被客户端缓存，以及可以被哪些客户端缓存这个策略的作用只有一个，用于决定 Http 响应内容是否可缓存到客户端</p>
<ul>
<li>对于 Cache-Control 头里的 Public、Private、no-cache、max-age 、no-store 他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。另关于 no-cache 和 max-age 有点特别，我认为它是一种混合体，下面我会讲到。</li>
</ul>
</blockquote>
<ul>
<li>通过 Cache-Control：Public 设置我们可以将 Http 响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用，为啥？因为它无法确定本地缓存的数据是否可用（可能已经失效），还必须借助一套鉴别机制来确认才行， 这就是我们下面要讲到的“缓存过期策略”。</li>
</ul>
<h3 id="缓存过期策略"><a href="#缓存过期策略" class="headerlink" title="缓存过期策略"></a>缓存过期策略</h3><blockquote>
<p>客户端用来确认存储在本地的缓存数据是否已过期，进而决定是否要发请求到服务端获取数据<br>刚上面我们已经阐述了数据缓存到了本地后还需要经过判断才能使用，那么浏览器通过什么条件来判断呢？ 答案是：Expires，Expires 指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。</p>
</blockquote>
<p>不过 Http 缓存头设计并没有想象的那么规矩，像上面提到的 Cache-Control（这个头是在Http1.1里加进来的）头里的 no-cache 和 max-age 就是特例，它们既包含缓存存储策略也包含缓存过期策略，以 max-age 为例，他实际上相当于：</p>
<p>Cache-Control：public/private（这里不太确定具体哪个）<br>Expires：当前客户端时间 + maxAge 。<br>而 Cache-Control：no-cache 和 Cache-Control：max-age=0 （单位是秒）相当</p>
<p>这里需要注意的是：</p>
<p>Cache-Control 中指定的缓存过期策略优先级高于Expires，当它们同时存在的时候，后者会被覆盖掉。</p>
<p>缓存数据标记为已过期只是告诉客户端不能再直接从本地读取缓存了，需要再发一次请求到服务器去确认，并不等同于本地缓存数据从此就没用了，有些情况下即使过期了还是会被再次用到，具体下面会讲到。</p>
<h3 id="缓存对比策略"><a href="#缓存对比策略" class="headerlink" title="缓存对比策略"></a>缓存对比策略</h3><p>将缓存在客户端的数据标识发往服务端，服务端通过标识来判断客户端 缓存数据是否仍有效，进而决定是否要重发数据。</p>
<p>客户端检测到数据过期或浏览器刷新后，往往会重新发起一个 http 请求到服务器，服务器此时并不急于返回数据，而是看请求头有没有带标识（ If-Modified-Since、If-None-Match）过来，如果判断标识仍然有效，则返回304告诉客户端取本地缓存数据来用即可（这里要注意的是你必须要在首次响应时输出相应的头信息（Last-Modified、ETags）到客户端）。至此我们就明白了上面所说的本地缓存数据即使被认为过期，并不等于数据从此就没用了的道理了。</p>
<p>关于 Last-Modified，这个响应头使用要注意，可能会影响到缓存过期策略，具体原因，后面我会通过解答开篇提到的2道题来作说明。</p>
<p>以上就是我所认识的缓存策略，下面我将缓存策略三要素和常用的几个缓存头（项）结合一起，让大家更清晰的认识到它们之间的关系：<br><img src="http04.png" alt=""><br>通过上图我可以清晰的看到各缓存项分别属于哪个缓存策略范畴，这其中有部分重叠，它表明这些缓存项具有多重缓存策略，所以实际在分析缓存头的时候，除了常规的头外，我们还需要将这些具有双重缓存策略的项分解开来。</p>
<p>最后我们回到最开始提到的2道题目，我们来一起分解下：</p>
<p>第一道题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p>
<p>分析上述 Http 响应头发现有以下两项与缓存相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache </span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br></pre></td></tr></table></figure></p>
<p>我们上面讲到了 Cache-Control: no-cache 相当于 Cache-Control: max-age=0，且他们都是多重策略头，我们需将其分解：</p>
<p>Cache-Control: no-cache 等于 Cache-Control: max-age=0，<br>接着 Cache-Control: max-age=0 又可分解成：</p>
<p>Cache-Control: public/private （不确定是二者中的哪一个）<br>Expires: 当前时间<br>最终我们得到了以下完整的缓存策略三要素：<br><img src="http05.png" alt=""><br>所以最终结果是：浏览器会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比：</p>
<p>a）对比失败：服务器返回200并重发数据，客户端接收到数据后展示，并刷新本地缓存。</p>
<p>b）对比成功：服务器返回304且不重发数据，客户端收到304状态码后从本地读取缓存数据。以下为模拟此种情况下请求后的抓包情况：<br><img src="http06.png" alt=""><br>这道题本身不难，但若认为 no-cache 不会缓存数据到本地，那么你理解起来就会很矛盾，因为如果文件数据没有被本地缓存，服务器返回304后将会无法展示出图片内容，但实际上它是能正常展示的。这道题很好的证明了 no-cache 也会缓存数据到本地这一说法。<br>第二道题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: private</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p>
<p>解题思路和上题一样，首先先找到缓存相关项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private     </span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">这时我们会发现根本找不到缓存过期策略项，那答案会不会和上面一样？ 一时半会也分析不出答案，那只能实际测试下了：</span><br></pre></td></tr></table></figure></p>
<p><img src="http07.png" alt=""><br>再看看 Chrome 浏览器下抓包：<br><img src="http08.png" alt=""><br>可以看到，浏览器后续请求都直接取的本地缓存，看来的确存在某种缓存过期策略（根据我上面的缓存过期策略理论，浏览器如果直接从本地加载缓存数据，说明它相信本地缓存数据有效，那一定存在某种缓存过期判断条件）。这个问题百思不得其解，困扰了我好久，直到一次偶然的机会我在 Fiddler 响应信息面板里的 Caching 选项卡中找到了答案：<br>原来，在没有提供任何浏览器缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略：</p>
<p>根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。</p>
<p>贴一下Caching面板里的描述，英语好的同学可以精准翻译下：<br>最终我们得到了以下完整的缓存策略三要素：<br><img src="http10.png" alt=""><br>最终结果<br>浏览器会根据 Date 和 Last-Modified 之间的时间差值缓存一段时间，这段时间内会直接使用本地缓存数据而不会再去请求服务器（强制请求除外），缓存过期后，会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比并根据服务端的响应状态决定是否要从本地加载缓存数据。</p>
<p>总结<br>Http 缓存设置起来并不复杂，但却容易被轻视， 今天这篇文章结合2道题目，通过分析、解剖相关缓存头，从系统化角度对 Http 缓存机制做了一个较完整的剖析：Http 缓存机制实际上是 Http 缓存策略三个要素（纬度）相互作用的集合，所以在分析和设置 Http 报文缓存头时，只要能从中精准的分解出缓存三要素，我们就能非常准确的预判到缓存设置最终能达到的效果。</p>
<h1 id="浏览器缓存详解-expires-cache-control-last-modified-etag详细说明"><a href="#浏览器缓存详解-expires-cache-control-last-modified-etag详细说明" class="headerlink" title="浏览器缓存详解:expires,cache-control,last-modified,etag详细说明"></a>浏览器缓存详解:expires,cache-control,last-modified,etag详细说明</h1><p><img src="http11.png" alt=""></p>
<h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：</p>
<p>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT</p>
<p>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：</p>
<p>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT</p>
<p>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p>
<p>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求</p>
<h2 id="Etag工作原理"><a href="#Etag工作原理" class="headerlink" title="Etag工作原理"></a>Etag工作原理</h2><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：</p>
<p>Etag:“5d8c72a5edda8d6a:3239″</p>
<p>客户端的查询更新格式是这样的：</p>
<p>If-None-Match:“5d8c72a5edda8d6a:3239″</p>
<p>如果ETag没改变，则返回状态304。</p>
<p>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″</p>
<p>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。</p>
<p>If-None-Match:“5d8c72a5edda8d6a:3239“</p>
<p>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。</p>
<h2 id="Expires-1"><a href="#Expires-1" class="headerlink" title="Expires"></a>Expires</h2><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT</p>
<p>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。</p>
<h2 id="Last-Modified和Expires"><a href="#Last-Modified和Expires" class="headerlink" title="Last-Modified和Expires"></a>Last-Modified和Expires</h2><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。</p>
<h2 id="Etag和Expires"><a href="#Etag和Expires" class="headerlink" title="Etag和Expires"></a>Etag和Expires</h2><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.</p>
<h2 id="Last-Modified和Etag"><a href="#Last-Modified和Etag" class="headerlink" title="Last-Modified和Etag"></a>Last-Modified和Etag</h2><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败</p>
<p>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)</p>
<p>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存</p>
<p>过程如下:</p>
<p>1.客户端请求一个页面（A）。</p>
<p>2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。</p>
<p>3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。</p>
<p>4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。</p>
<p>5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</p>
<p>注：</p>
<p>1、Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。</p>
<p>2、WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；</p>
<p>3、客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；</p>
<p>4、通过上述值到服务器端检查，判断文件是否继续缓存；</p>
<p>7、关于 Cache-Control: max-age=秒 和 Expires</p>
<p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</p>
<p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p>
<p>Expires =max-age +   “每次下载时的当前的request时间”</p>
<p>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 </p>
<h1 id="浏览器缓存总结"><a href="#浏览器缓存总结" class="headerlink" title="浏览器缓存总结"></a>浏览器缓存总结</h1><p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：</p>
<ul>
<li>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li>
<li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li>
<li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；</li>
<li>区别是，强缓存不对发送请求到服务器，但协商缓存会。</li>
<li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li>
<li>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li><p>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p>
<blockquote>
<p>强缓存</p>
</blockquote>
</li>
<li><p>Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）</p>
</li>
<li><p>Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）</p>
<blockquote>
<p>协商缓存</p>
</blockquote>
</li>
<li><p>Last-Modified（值为资源最后更新时间，随服务器response返回）</p>
</li>
<li>If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li>
<li>ETag（表示资源内容的唯一标识，随服务器response返回）</li>
<li>If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li>
</ul>

                
                <div class="readmore">
                    <a href="/2018/12/27/浏览器缓存/">
                        阅读更多
                    </a>
                </div>
            </div>
        
    </div>


    <div id="content-aside">
    <div class="content-aside-owner">
        <div id="owner">
    <div class="avatar-bg">
        <div class="index-page">
            <div class="banner">
                <div class="slide slide1">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_left">
                            <div id="canvas_left"></div>
                        </div>
                    </div>
                </div>
                <div class="slide slide2">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_right">
                            <div id="canvas_right"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a href="/"><img class="avatar" src="/images/avatar.jpg" alt=""></a>
    <a href="/"><h3 class="author">I&#39;m xiedandan</h3></a>
    <h4>^_^</h4>
    <div class="social">
        
            
              <a href="https://github.com/xdd7130" title="github" class="fa fa-github" target="_blank"></a>
            
        
            
              <a href="#" title="weibo" class="fa fa-weibo" target="_blank"></a>
            
        
    </div>
</div>
    </div>
    
        <div class="content-aside-about">
            <h2>
                <a href="/about">关于</a>
            </h2>
        </div>
    
    <div class="content-aside-tags">
        <h2>
            <a href="/tags">
                标签
                <sup style="font-size: 12px">
                    [25]
                </sup>
            </a>
        </h2>
    </div>
    
<aside id="categories">
    <h2>分类</h2>
    
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ArcGIS/">ArcGIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VUE/">VUE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他前端技术/">其他前端技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
    
</aside>

    
<aside id="acchives">
    <h2>归档</h2>
    
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    
</aside>

</div>

</div>
<nav id="pagination" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">下一页 &raquo;</a>
</nav>

    </div>
</div>
<footer id="footer">
     <div id="copyright">&copy; I&#39;m xiedandan  2020</div>
     
             <!-- 不蒜子统计 -->
             <span id="busuanzi_container_site_pv">
                     本站总访问量<span id="busuanzi_value_site_pv" style='color:#17a167'></span>次
             </span>
             <span class="post-meta-divider">|</span>
             <span id="busuanzi_container_site_uv">
                     本站访客数<span id="busuanzi_value_site_uv"  style='color:#17a167'></span>人
             </span>
             <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
       
    <div id="theme">
        Powered by <a href="http://hexo.io">Hexo</a>. Theme by <a href="https://github.com/markyong/hexo-theme-stage">Stage</a>
    </div>
</footer>
<script src="/lib/js/waterrippleeffect.min.js"></script>
<script src="/js/header-bg.main.js"></script>

    <script src="/lib/js/cav.js"></script>
    <script src="/js/avatar-bg.main.js"></script>

</body>
</html>
