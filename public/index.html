
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <title>DD_XIE的学习笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="">
    <meta name="description" content="前端学习">
    
        <link rel="icon" href="/favicon.ico">
    
    
        
            <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
        
            <link rel="stylesheet" href="/css/stage.css">
        
            <link rel="stylesheet" href="/css/avatar-bg.css">
        
    
</head>
</html>
<body>
<header id="header">
    <div class="menu">
        <i class="fa fa-bars"></i>
    </div>
    <div class="header-main">
        <h1><a href="/">DD_XIE的学习笔记</a></h1>
    </div>
    <div id="nav">
        <div class="nav-img" id="nav-img"></div>
        <div class="sentences">
            也许世界就这样，我也还在路上。
        </div>
    </div>
</header>

<div id="content-outer">
    <div id="content-inner">
        <div class="clearfix">
    
    <div id="recent-posts">
        
            <div class="post-item">
                <h1>
                    <a href="/2021/01/23/react-hooks/">
                        Hooks
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2021-01-23T07:25:06.000Z">
                            2021-01-23
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/React/">React</a></li></ul>
                </div>
                
                    
                
                <div class="readmore">
                    <a href="/2021/01/23/react-hooks/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2021/01/17/react-redux/">
                        Redux
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2021-01-17T14:25:42.000Z">
                            2021-01-17
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/React/">React</a></li></ul>
                </div>
                
                    <h3 id="🌴-Redux"><a href="#🌴-Redux" class="headerlink" title="🌴 Redux"></a>🌴 Redux</h3><h3 id="🌴-React-Redux"><a href="#🌴-React-Redux" class="headerlink" title="🌴 React-Redux"></a>🌴 React-Redux</h3><p><a href="https://github.com/xdd7130/REACT/tree/main/react-04-router" target="_blank" rel="noopener">demo代码</a></p>
<h4 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h4><p>只负责 UI 的呈现，不带有任何业务逻辑<br>没有状态（即不使用this.state这个变量）<br>所有数据都由参数（this.props）提供<br>不使用任何 Redux 的 API</p>
<h4 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h4><p>负责管理数据和业务逻辑，不负责 UI 的呈现<br>带有内部状态<br>使用 Redux 的 API<br>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p>
<p>如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。</p>
<p>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from <span class="string">'react-redux'</span></span><br><span class="line">const VisibleTodoList = connect()(TodoList);</span><br></pre></td></tr></table></figure>
<p>上面VisibleTodoList 便是通过UI组件TodoList,通过connect方法自动生成的容器组件。<br>但需要定义业务逻辑，组件才有意义。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line">const VisibleTodoList = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure></p>
<p>connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h4 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a>mapStateToProps()</h4><p>它是一个函数，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。<br>mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。</p>
<h4 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a>mapDispatchToProps()</h4><p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p>
<p>是函数则会得到dispatch和ownProps（容器组件的props对象）两个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = (</span><br><span class="line">  dispatch,</span><br><span class="line">  ownProps</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onClick: () =&gt; &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: &apos;SET_VISIBILITY_FILTER&apos;,</span><br><span class="line">        filter: ownProps.filter</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p>
<p>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">  onClick: (filter) =&gt; &#123;</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">    filter: filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Provider-组件"><a href="#Provider-组件" class="headerlink" title="Provider 组件"></a>Provider 组件</h4><p>connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。<br>React-Redux 提供Provider组件，可以让容器组件拿到state。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from <span class="string">'react-redux'</span></span><br><span class="line">import &#123; createStore &#125; from <span class="string">'redux'</span></span><br><span class="line">import todoApp from <span class="string">'./reducers'</span></span><br><span class="line">import App from <span class="string">'./components/App'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> store = createStore(todoApp);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>

                
                <div class="readmore">
                    <a href="/2021/01/17/react-redux/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2021/01/14/react路由/">
                        路由
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2021-01-14T01:21:19.000Z">
                            2021-01-14
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/React/">React</a></li></ul>
                </div>
                
                    <p><a href="https://github.com/xdd7130/REACT/tree/main/react-04-router" target="_blank" rel="noopener">demo代码</a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>react-ruter: 核心库</li>
<li>react-router-dom: 基于核心库在 web端 使用的库</li>
<li>react-router-native: 基于核心库在 React Native 使用的库</li>
<li>react-router-config:  用于配置静态路由的库,随着 React Router v4 的引入，不再有集中式路由配置</li>
<li>react-router-redux: 集成 Redux 的库,已经不推荐使用，推荐使用 connected-react-router 和 Redux 进行配合使用</li>
</ul>
<p>如果只在浏览器端使用，直接安装 react-router-dom.</p>
<h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><p> React Router有三大组件：</p>
<ul>
<li>router components 路由器，<code>&lt;BrowserRouter&gt;</code>、<code>&lt;HashRouter&gt;</code></li>
<li>route matching components 路线匹配器，<code>&lt;Route&gt;</code>、<code>&lt;Switch&gt;</code></li>
<li>navigation components 导航，<code>&lt;Link&gt;</code>、<code>&lt;NavLink&gt;</code>、<code>&lt;Redirect&gt;</code></li>
</ul>
<p>其他还有 <code>&lt;MemoryRouter&gt;</code>  内存路由组件、<code>&lt;NativeRouter&gt;</code>  Native的路由组件、<code>&lt;StaticRouter&gt;</code> 静态路由组件这些路由组件，其中 MemoryRouter 主要用在 ReactNative 这种非浏览器的环境中，因此直接将 URL 的 history 保存在了内容中。StaticRouter 主要用于服务器端渲染</p>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>react-router-dom 提供了BrowserRouter 和 HashRouter 两个路由，这两个路由都会创建一个专门的 history 对象。两者之间的主要区别是它们存储 URL 和与 Web 服务器通信的方式</p>
<blockquote>
<p>BrowserRouter <a href="http://localhost:3000/byd" target="_blank" rel="noopener">http://localhost:3000/byd</a><br>HashRouter <a href="http://localhost:3000/#/byd" target="_blank" rel="noopener">http://localhost:3000/#/byd</a> 两者生成的 URL 区别在于有没有 </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserRouter, Route, Link &#125; from <span class="string">"react-router-dom"</span>;</span><br></pre></td></tr></table></figure>
<p>BrowserRouter 容器，用来存放 Router、Link<br>BrowserRouter 提供了如下属性:</p>
<ul>
<li>basename (string) 当前位置的基准 URL</li>
<li>forceRefresh (boolean)，在导航的过程中整个页面是否刷新</li>
<li>getUserConfirmation (func)，当导航需要确认时执行的函数。默认是：window.confirm</li>
<li>keyLength (number)  location.key 的长度。默认是 6</li>
<li>children (node) 要渲染的子节点</li>
</ul>
<blockquote>
<p>HashRouter 不支持 location.key 和 location.state ，所以在浏览器中建议使用 BrowserRouter</p>
</blockquote>
<h4 id="路线匹配器"><a href="#路线匹配器" class="headerlink" title="路线匹配器"></a>路线匹配器</h4><blockquote>
<p>Route： location 与 Route 的 path 匹配时，渲染 Route 中的 Component</p>
<ul>
<li>Route 接受三种渲染方式：<code>&lt;Route component&gt;</code>、<code>&lt;Route render&gt;</code>、<code>&lt;Route children&gt;</code>。<br>(1)render: function 类型，Route 会渲染这个 function 的返回值，可以在函数中附加一些额外的逻辑，所以你可以在render中添加一些逻辑判断，再返回一个要渲染的 component。<br>(2)children: function 类型，比 render 多了 match参数，可以根据 match参数来决定匹配的时候渲染什么，不匹配的时候渲染什么<br>Route 经常用的是 exact、path 以及 component 属性。</li>
</ul>
</blockquote>
<ul>
<li>exact 是否进行精确匹配，路由 /a 可以和 /a/、/a 匹配。</li>
<li>strict 是否进行严格匹配，指明路径只匹配以斜线结尾的路径，路由/a可以和/a匹配，不能和/a/匹配，相比 exact 会更严格些。</li>
<li>path (string) 标识路由的路径，没有 path 属性的 Route 总是会匹配。</li>
<li>component 表示路径对应显示的组件。</li>
<li>location (object) 除了通过 path 传递路由路径，也可以通过传递 location 对象可以匹配。</li>
<li>sensitive (boolean) 匹配路径时，是否区分大小写。</li>
<li>Route 组件都接收 location、history、match三个 props：三个 props 比较常用的是 match，通过 match.params 可以取到动态参数的值。</li>
</ul>
<p><img src="/2021/01/14/react路由/01.png" alt="01.png"><br><img src="/2021/01/14/react路由/02.png" alt="02.png"></p>
<blockquote>
<p>Swtich:就近匹配路由，仅渲染一个路由，路由的默认行为是匹配了就直接渲染，大部分场景下这个逻辑是没有问题的，但考虑下面的场景</p>
</blockquote>
<h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><p>Link 声明路由要跳转的地方 </p>
<ul>
<li>to（string | object | function） 需要跳转到的路径(pathname) 或地址（location）<br>(1)为 string 时 就是一个明确的路径地址<br>(2)为 object 时有如下属性（就是一个location对象）<br>pathname：URL路径。<br>search：URl中查询字符串。<br>hash：URL的hash分段，例如#a-hash。<br>state：表示location中的状态<br>(3)为 function 时，就是一个函数接收当前 location 为参数，然后以字符串或对象的形式返回位置形式</li>
<li>replace (boolean) 为 true 是替换历史记录，false 是新增历史记录</li>
</ul>
<p>NavLink 功能与 Link 类似不过参数更多，并且可以设置被选中时的样式或者类</p>
<ul>
<li>exact (boolean) 是否进行精确匹配</li>
<li>strict (boolean) 是否进行严格匹配</li>
<li>to（string | object） 需要跳转到的路径(pathname)或地址（location）</li>
<li>activeClassName (string) 是选中状态的类名，我们可以为其添加样式</li>
<li>activeStyle (Object) 元素处于选中状态时，应用于元素的样式</li>
<li>isActive(function) 添加额外逻辑以确定链接是否处于活动状态</li>
</ul>
<p>Redirect 重定向组件</p>
<ul>
<li>from (string) 需要重定向的路径，可以包括动态参数</li>
<li>push (boolean) 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目</li>
<li>to (string | object) 重定向到的路径</li>
<li>exact (boolean) 是否要对 from 进行精确匹配</li>
<li>strict (boolean) 是否要对 from 进行严格匹配</li>
<li>sensitive (boolean) 匹配 from 时是否区分大小写</li>
</ul>
<h3 id="react-router与react-router-dom"><a href="#react-router与react-router-dom" class="headerlink" title="react-router与react-router-dom"></a>react-router与react-router-dom</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>React-router：提供了router的核心api。如Router、Route、Switch等，但没有提供有关dom操作进行路由跳转的ap；</p>
<p>React-router-dom：提供了BrowserRouter、HashRouter、Link等api，可以通过dom操作触发事件控制路由。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>React-router：实现了路由的核心功能</p>
<p>React-router-dom：基于React-router，加入了一些在浏览器运行下的一些功能.</p>
<p>例如：Link组件会渲染一个a标签，</p>
<p>　　　BrowserRouter使用 HTML5 提供的 history API可以保证你的 UI 界面和 URL 保持同步，</p>
<p>　　　HashRouter使用 URL 的 hash 部分保证你的 UI 界面和 URL 保持同步</p>
<h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><p>React-router不能通过操作dom控制路由，此时还需引入React-router-dom<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mport &#123;Switch, Route, Router&#125; from <span class="string">'react-router'</span>;</span><br><span class="line">import &#123;HashHistory, Link&#125; from <span class="string">'react-router-dom'</span>;</span><br></pre></td></tr></table></figure></p>
<p>React-router-dom在React-router的基础上扩展了可操作dom的api</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Swtich, Route, Router, HashHistory, Link&#125; from <span class="string">'react-router-dom'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h4><p>React-router：router4.0以上版本用this.props.history.push(‘/path’)实现跳转；</p>
<p>　　　　　　　router3.0以上版本用this.props.router.push(‘/path’)实现跳转</p>
<p>React-router-dom：直接用this.props.history.push(‘/path’)就可以实现跳转</p>
<p>#### </p>

                
                <div class="readmore">
                    <a href="/2021/01/14/react路由/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2021/01/09/Iterator/">
                        ES6(四) Iterator
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2021-01-09T01:52:51.000Z">
                            2021-01-09
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h3 id="遍历器（Iterator）"><a href="#遍历器（Iterator）" class="headerlink" title="遍历器（Iterator）"></a>遍历器（Iterator）</h3><p>为某种数据结构提供一种统一的访问机制，遍历器本质是一个只针对象</p>
<p>1、JS中表示”集合“的数据结构有：数组（Array），对象（Object），Map和Set。但有的可直接遍历，有的在部署Iterator才可以遍历。<br>2、遍历器为各种不同的数据提供访问机制，任何数据结构只要部署Iterator,就可以遍历处理该数据结构的所有成员。<br>3、遍历器作用：</p>
<ul>
<li>（1）为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>（2）使得数据结构的成员能够按某种次序排列；</li>
<li>（3）ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费</li>
</ul>
<p>4、遍历过程过程：</p>
<ul>
<li><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
</li>
<li><p>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p>
</li>
<li><p>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</p>
</li>
<li><p>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p>
</li>
</ul>
<p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束</p>
<h3 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h3><p>1、Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环；<br>2、一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）<br>3、ES6 规定，默认的 Iterator 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，即，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。</p>

                
                <div class="readmore">
                    <a href="/2021/01/09/Iterator/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2021/01/08/es6-async/">
                        ES6(五) async
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2021-01-08T02:25:20.000Z">
                            2021-01-08
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <p>### </p>

                
                <div class="readmore">
                    <a href="/2021/01/08/es6-async/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2021/01/06/es6-3/">
                        ES6(五) Generator
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2021-01-06T01:13:36.000Z">
                            2021-01-06
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h3 id="🌴-概述"><a href="#🌴-概述" class="headerlink" title="🌴 概述"></a>🌴 概述</h3><p>Generator 函数是一个状态机，可以封装多个内部状态。<br>两个特征：<br>1、function关键字与函数名之间有一个星号<br>2、函数体内部使用yield表达式，定义不同的内部状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">helloWorldGenerator</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'hello'</span>;</span><br><span class="line">  yield <span class="string">'world'</span>;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure></p>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。<br>必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line">// &#123; value: <span class="string">'hello'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: <span class="string">'world'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: <span class="string">'ending'</span>, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>综上，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
<h3 id="🌴-yield-表达式"><a href="#🌴-yield-表达式" class="headerlink" title="🌴 yield 表达式"></a>🌴 yield 表达式</h3><p>1、yield表达式就是暂停标志。<br>2、yield表达式与return语句<br>相似点：<br>都能返回紧跟在语句后面的那个表达式的值<br>区别：<br>每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。<br>3、Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'执行了！'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var generator = f();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  generator.next()</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure></p>
<p>4、yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。<br>5、yield表达式如果用在另一个表达式之中，必须放在圆括号里面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">demo</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'Hello'</span> + yield); // SyntaxError</span><br><span class="line">  console.log(<span class="string">'Hello'</span> + yield 123); // SyntaxError</span><br><span class="line"></span><br><span class="line">  console.log(<span class="string">'Hello'</span> + (yield)); // OK</span><br><span class="line">  console.log(<span class="string">'Hello'</span> + (yield 123)); // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6、yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">demo</span></span>() &#123;</span><br><span class="line">  foo(yield <span class="string">'a'</span>, yield <span class="string">'b'</span>); // OK</span><br><span class="line">  <span class="built_in">let</span> input = yield; // OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="🌴-next-方法的参数"><a href="#🌴-next-方法的参数" class="headerlink" title="🌴 next 方法的参数"></a>🌴 next 方法的参数</h3><p>1、<font color="red">yield表达式本身没有返回值，或者说总是返回undefined。</font><br>2、next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* foo(x) &#123;</span><br><span class="line">  var y = 2 * (yield (x + 1));</span><br><span class="line">  var z = yield (y / 3);</span><br><span class="line">  <span class="built_in">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = foo(5);</span><br><span class="line">a.next() // Object&#123;value:6, <span class="keyword">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">a.next() // Object&#123;value:NaN, <span class="keyword">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">a.next() // Object&#123;value:NaN, <span class="keyword">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">var b = foo(5);</span><br><span class="line">b.next() // &#123; value:6, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(12) // &#123; value:8, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(13) // &#123; value:42, <span class="keyword">done</span>:<span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="🌴-for…of"><a href="#🌴-for…of" class="headerlink" title="🌴 for…of"></a>🌴 for…of</h3><p>for…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。<br>一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  yield 4;</span><br><span class="line">  yield 5;</span><br><span class="line">  <span class="built_in">return</span> 6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> v of foo()) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 4 5</span><br></pre></td></tr></table></figure></p>
<h3 id="Generator函数异步编程"><a href="#Generator函数异步编程" class="headerlink" title="Generator函数异步编程"></a>Generator函数异步编程</h3><ul>
<li><p>回调函数</p>
</li>
<li><p>事件监听</p>
</li>
<li><p>发布/订阅</p>
</li>
<li><p>Promise 对象</p>
</li>
</ul>

                
                <div class="readmore">
                    <a href="/2021/01/06/es6-3/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2021/01/05/Promise/">
                        ES6(三) Promise
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2021-01-05T02:25:07.000Z">
                            2021-01-05
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">参考</a></p>
<h3 id="🌴-概述"><a href="#🌴-概述" class="headerlink" title="🌴 概述"></a>🌴 概述</h3><p>首先，Promise 是一个对象，也是一个构造函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f1(resolve, reject) &#123;</span><br><span class="line">  // 异步代码</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Promise(f1)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Promise构造函数接受一个回调函数f1作为参数，f1里面是异步操作的代码。然后，返回的p1就是一个 Promise 实例。</p>
<p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(f1);</span><br><span class="line">p1.then(f2);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，f1的异步操作执行完成，就会执行f2。</p>
<p>传统的写法可能需要把f2作为回调函数传入f1，比如写成f1(f2)，异步操作完成后，在f1内部调用f2。Promise 使得f1和f2变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">step1(<span class="keyword">function</span> (value1) &#123;</span><br><span class="line">  step2(value1, <span class="keyword">function</span>(value2) &#123;</span><br><span class="line">    step3(value2, <span class="keyword">function</span>(value3) &#123;</span><br><span class="line">      step4(value3, <span class="keyword">function</span>(value4) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Promise 的写法</span><br><span class="line">(new Promise(step1))</span><br><span class="line">  .<span class="keyword">then</span>(step2)</span><br><span class="line">  .<span class="keyword">then</span>(step3)</span><br><span class="line">  .<span class="keyword">then</span>(step4);</span><br></pre></td></tr></table></figure></p>
<p>从上面代码可以看到，采用 Promise 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的Promise实例的生成格式，做了简化，真正的语法请参照下文。</p>
<p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程</p>
<h3 id="🌴-关键词"><a href="#🌴-关键词" class="headerlink" title="🌴 关键词"></a>🌴 关键词</h3><h4 id="👉异步操作解决方案"><a href="#👉异步操作解决方案" class="headerlink" title="👉异步操作解决方案"></a>👉异步操作解决方案</h4><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。比传统的解决方案:回调函数和事件，更强大,它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<h4 id="👉-三种状态"><a href="#👉-三种状态" class="headerlink" title="👉 三种状态"></a>👉 三种状态</h4><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<blockquote>
<p>异步操作未完成（pending）</p>
</blockquote>
<blockquote>
<p>异步操作成功（fulfilled）</p>
</blockquote>
<blockquote>
<p>异步操作失败（rejected）</p>
</blockquote>
<p>上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。</p>
<p>这三种的状态的变化途径只有两种。</p>
<blockquote>
<p>从“未完成”到“成功”</p>
</blockquote>
<blockquote>
<p>从“未完成”到“失败”</p>
</blockquote>
<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p>
<p>因此，Promise 的最终结果只有两种。</p>
<blockquote>
<p>异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。</p>
</blockquote>
<blockquote>
<p>异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected</p>
</blockquote>
<h4 id="👉-Promise-API"><a href="#👉-Promise-API" class="headerlink" title="👉 Promise API"></a>👉 Promise API</h4><ul>
<li>Promise.prototype.catch()</li>
<li>Promise.prototype.finally()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
<li>promise.allSettled()</li>
<li>promise.any()</li>
<li>Promise.resolve()</li>
<li>Promise.reject()</li>
<li>Promise.try()</li>
</ul>
<h3 id="🌴-Promise-构造函数"><a href="#🌴-Promise-构造函数" class="headerlink" title="🌴 Promise 构造函数"></a>🌴 Promise 构造函数</h3><p>JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; /* 异步操作失败 */</span><br><span class="line">    reject(new Error());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>
<p>resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>下面是一个例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).<span class="keyword">then</span>(<span class="keyword">function</span>(val)&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;)</span><br><span class="line">或</span><br><span class="line">timeout(100).<span class="keyword">then</span>((val)=&gt;&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，timeout(100)返回一个Promise实例。100毫秒以后，该实例的状态会变为fulfilled</p>
<h3 id="🌴-Promise-API用法"><a href="#🌴-Promise-API用法" class="headerlink" title="🌴 Promise API用法"></a>🌴 Promise API用法</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>Promise 实例的then方法，定义在原型对象上，用来添加回调函数。</p>
<p>then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(<span class="string">'成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(console.log, console.error);</span><br><span class="line">// <span class="string">"成功"</span></span><br><span class="line"></span><br><span class="line">var p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  reject(new Error(<span class="string">'失败'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(console.log, console.error);</span><br><span class="line">// Error: 失败</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p1和p2都是Promise 实例，它们的then方法绑定两个回调函数：成功时的回调函数console.log，失败时的回调函数console.error（可以省略）。p1的状态变为成功，p2的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。</p>
<p>then方法可以链式使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br><span class="line">  .<span class="keyword">then</span>(step1)</span><br><span class="line">  .<span class="keyword">then</span>(step2)</span><br><span class="line">  .<span class="keyword">then</span>(step3)</span><br><span class="line">  .<span class="keyword">then</span>(</span><br><span class="line">    console.log,</span><br><span class="line">    console.error</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。</p>
<p>最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise 开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。</p>
<p>Promise 的用法，简单说就是一句话：使用then方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">f1().<span class="keyword">then</span>(fun</span><br><span class="line"><span class="function"><span class="title">ction</span></span> () &#123;</span><br><span class="line">  f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">f1().<span class="keyword">then</span>(f2());</span><br><span class="line"></span><br><span class="line">// 写法四</span><br><span class="line">f1().<span class="keyword">then</span>(f2);</span><br></pre></td></tr></table></figure></p>
<p>为了便于讲解，下面这四种写法都再用then方法接一个回调函数f3。写法一的f3回调函数的参数，是f2函数的运行结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> f2();</span><br><span class="line">&#125;).<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法二的f3回调函数的参数是undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  f2();</span><br><span class="line">  <span class="built_in">return</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法三的f3回调函数的参数，是f2函数返回的函数的运行结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(f2())</span><br><span class="line">  .<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<p>写法四与写法一只有一个差别，那就是f2会接收到f1()返回的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().<span class="keyword">then</span>(f2)</span><br><span class="line">  .<span class="keyword">then</span>(f3);</span><br></pre></td></tr></table></figure></p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>1、Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br><span class="line">  console.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2、Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(post) &#123;</span><br><span class="line">  <span class="built_in">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(comments) &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // 处理前面三个Promise产生的错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，一共有三个 Promise 对象：一个由getJSON()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。<br>3、一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。<br>4、catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。</p>
<h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h4><p>1、finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。<br>2、不接受任何参数，不依赖promise执行结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="keyword">then</span>(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><ul>
<li>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<p>1、p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例<br>2、Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例<br>3、只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>4、只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><ul>
<li>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>1、只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。<br>2、Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。<br>3、状态不可逆：如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(<span class="string">'request timeout'</span>)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.<span class="keyword">then</span>(console.log)</span><br><span class="line">.catch(console.error);</span><br></pre></td></tr></table></figure></p>
<h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h4><p>1、Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束<br>2、Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled。、<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const resolved = Promise.resolve(42);</span><br><span class="line">const rejected = Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const allSettledPromise = Promise.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="keyword">function</span> (results) &#123;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;);</span><br><span class="line">// [</span><br><span class="line">//    &#123; status: <span class="string">'fulfilled'</span>, value: 42 &#125;,</span><br><span class="line">//    &#123; status: <span class="string">'rejected'</span>, reason: -1 &#125;</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure></p>
<h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h4><p>接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promises = [</span><br><span class="line">  fetch(<span class="string">'/endpoint-a'</span>).<span class="keyword">then</span>(() =&gt; <span class="string">'a'</span>),</span><br><span class="line">  fetch(<span class="string">'/endpoint-b'</span>).<span class="keyword">then</span>(() =&gt; <span class="string">'b'</span>),</span><br><span class="line">  fetch(<span class="string">'/endpoint-c'</span>).<span class="keyword">then</span>(() =&gt; <span class="string">'c'</span>),</span><br><span class="line">];</span><br><span class="line">try &#123;</span><br><span class="line">  const first = await Promise.any(promises);</span><br><span class="line">  console.log(first);</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>1、将现有对象转为 Promise 对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(<span class="string">'foo'</span>)</span><br><span class="line">// 等价于</span><br><span class="line">new Promise(resolve =&gt; resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure></p>
<p>2、Promise.resolve()方法的参数分成四种情况：<br>（1）参数是一个 Promise 实例<br>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p>
<p>（2）参数是一个thenable对象<br>thenable对象指的是具有then方法的对象，比如下面这个对象。<br>thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出42。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> thenable = &#123;</span><br><span class="line">  <span class="keyword">then</span>: <span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    resolve(42);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> p1 = Promise.resolve(thenable);</span><br><span class="line">p1.then(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">  console.log(value);  // 42</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>(3)参数不是具有then()方法的对象，或根本就不是对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="keyword">function</span> (s) &#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。</p>
<p>（4）不带有任何参数<br>Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">// 等同于</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(null, <span class="keyword">function</span> (s) &#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure></p>
<h3 id="🌴-小结"><a href="#🌴-小结" class="headerlink" title="🌴 小结"></a>🌴 小结</h3><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p>
<p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>
<p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p>
<h3 id="🌴-微任务"><a href="#🌴-微任务" class="headerlink" title="🌴 微任务"></a>🌴 微任务</h3><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">&#125;).<span class="keyword">then</span>(console.log);</span><br><span class="line"></span><br><span class="line">console.log(2);</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码会先输出2，再输出1。因为console.log(2)是同步任务，而then的回调函数属于异步任务，一定晚于同步任务执行。</p>
<p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  resolve(2);</span><br><span class="line">&#125;).<span class="keyword">then</span>(console.log);</span><br><span class="line"></span><br><span class="line">console.log(3);</span><br><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>上面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。</p>

                
                <div class="readmore">
                    <a href="/2021/01/05/Promise/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2020/12/29/React生命周期/">
                        生命周期
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2020-12-29T11:33:26.000Z">
                            2020-12-29
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/React/">React</a></li></ul>
                </div>
                
                    <p>在组件的整个生命周期中，随着该组件的props或者state发生改变，其DOM表现也会有相应的变化。</p>
<p>一个组件就是一个状态机，对于特定地输入，它总返回一致的输出。</p>
<p>一个React组件的生命周期分为三个部分：实例化、存在期和销毁时。</p>
<p>React应用中，组件加载顺序及生命周期如下图所示：</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor( )"></a>constructor( )</h3><p>constructor是ES6对类的默认方法，通过 new 命令生成对象实例时自动调用该方法。并且，该方法是类中必须有的，如果没有显示定义，则会默认添加空的constructor( )方法。当存在constructor的时候⚠️必须手动调用super方法。 在constructor中如果要访问this.props需要传入props，示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyClass extends React.component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props); // 声明constructor时必须调用super方法</span><br><span class="line">        console.log(this.props); // 可以正常访问this.props</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor 常用来初始化state</span><br><span class="line"></span><br><span class="line">class MyClass extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            list: this.props.List</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h3><p>该方法在组件挂载之前生效。 在组件挂载之前调用且全局只调用一次。如果在这个钩子里可以setState，render后可以看到更新后的state，不会触发重复渲染。该生命周期可以发起异步请求，并setState。（React v16.3后废弃该生命周期，可以在constructor中完成设置state）</p>
<h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><p>render是一个React组件必须定义的生命周期，用来渲染dom。⚠️不要在render里面修改state，会触发死循环导致栈溢出。render必须返回reactDom。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">	const &#123;nodeResultData: &#123;res&#125; = &#123;&#125;&#125; = this.props;</span><br><span class="line">	<span class="keyword">if</span> (isEmpty(res)) <span class="built_in">return</span> noDataInfo;</span><br><span class="line">	const nodeResult = this.getNodeResult(res);</span><br><span class="line">	<span class="built_in">return</span> (</span><br><span class="line">		&lt;div className=<span class="string">"workspace-dialog-result"</span>&gt;</span><br><span class="line">			&#123;nodeResult&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	);</span><br></pre></td></tr></table></figure></p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p>在组件挂载完成后调用，且全局只调用一次。可以在这里使用refs，获取真实dom元素。该钩子内也可以发起异步请求，并在异步请求中可以进行setState。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">	axios.get(<span class="string">'/auth/getTemplate'</span>).<span class="keyword">then</span>(res =&gt; &#123;</span><br><span class="line">		const &#123;TemplateList = []&#125; = res;</span><br><span class="line">		this.setState(&#123;TemplateList&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps (nextProps )"></a>componentWillReceiveProps (nextProps )</h3><p>props发生变化以及父组件重新渲染时都会触发该生命周期，在该钩子内可以通过参数nextProps获取变化后的props参数，通过this.props访问之前的props。该生命周期内可以进行setState。(React v16.3后废弃该生命周期，可以用新的周期 static getDerivedStateFromProps 代替)</p>
<h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h3><p>用于判断是否重新渲染，组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。返回false则不触发渲染。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。</p>
<h3 id="componentWillUpdate-nextProps-nextState"><a href="#componentWillUpdate-nextProps-nextState" class="headerlink" title="componentWillUpdate(nextProps, nextState)"></a>componentWillUpdate(nextProps, nextState)</h3><p>shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。不能在该钩子中setState，会触发重复循环。(React v16.3后废弃该生命周期，可以用新的周期 getSnapshotBeforeUpdate)</p>
<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h3><p>完成组件渲染，除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。该钩子内setState有可能会触发重复渲染，需要自行判断，否则会进入死循环。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidUpdate</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(condition) &#123;</span><br><span class="line">        this.setState(&#123;..&#125;) // 设置state</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 不再设置state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><p>组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。</p>

                
                <div class="readmore">
                    <a href="/2020/12/29/React生命周期/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2020/11/23/ES6-2/">
                        ES6(二) Set和Map
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2020-11-23T11:18:34.000Z">
                            2020-11-23
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h3 id="🌴-Set-和-WeakSet数据结构"><a href="#🌴-Set-和-WeakSet数据结构" class="headerlink" title="🌴 Set 和 WeakSet数据结构"></a>🌴 Set 和 WeakSet数据结构</h3><h4 id="👉-Set："><a href="#👉-Set：" class="headerlink" title="👉 Set："></a>👉 Set：</h4><p>1、ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//add方法</span><br><span class="line">const s = new Set();</span><br><span class="line"></span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of s) &#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 2 3 5 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 一、 数组去重</span><br><span class="line">[...new Set(array)]</span><br><span class="line">// 二、Array.from方法可以将 Set 结构转为数组。</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">const array = Array.from(items);</span><br></pre></td></tr></table></figure>
<p>2、Set 实例的属性和方法</p>
<ul>
<li>实例属性：<br>Set.prototype.constructor：构造函数，默认就是Set函数。<br>Set.prototype.size：返回Set实例的成员总数。</li>
<li>实例方法:<br>Set.prototype.add(value)：添加某个值，返回 Set 结构本身。<br>Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。<br>Set.prototype.clear()：清除所有成员，没有返回值。</li>
</ul>
<p>例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">// 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size // 2</span><br><span class="line"></span><br><span class="line">s.has(1) // <span class="literal">true</span></span><br><span class="line">s.has(2) // <span class="literal">true</span></span><br><span class="line">s.has(3) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">s.delete(2);</span><br><span class="line">s.has(2) // <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>3、遍历操作</p>
<p>四个遍历方法：</p>
<p>Set.prototype.keys()：返回键名的遍历器<br>Set.prototype.values()：返回键值的遍历器<br>Set.prototype.entries()：返回键值对的遍历器<br>Set.prototype.forEach()：使用回调函数遍历每个成员</p>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别:<br>1、WeakSet 的成员只能是对象，而不能是其他类型的值。<br>2、WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</p>
<p>WeakSet 结构有以下三个方法：</p>
<p>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中</p>
<h3 id="🌴-Map-和-WeakMap数据结构"><a href="#🌴-Map-和-WeakMap数据结构" class="headerlink" title="🌴 Map 和 WeakMap数据结构"></a>🌴 Map 和 WeakMap数据结构</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。<br>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>)</span><br><span class="line">m.get(o) // <span class="string">"content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) // <span class="literal">true</span></span><br><span class="line">m.delete(o) // <span class="literal">true</span></span><br><span class="line">m.has(o) // <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.<span class="built_in">set</span>(1, <span class="string">'aaa'</span>)</span><br><span class="line">.<span class="built_in">set</span>(1, <span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line">map.get(1) // <span class="string">"bbb"</span></span><br></pre></td></tr></table></figure></p>
<p>如果读取一个未知的键，则返回undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Map().get(<span class="string">'asfddfsasadf'</span>)</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure></p>
<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">'a'</span>], 555);</span><br><span class="line">map.get([<span class="string">'a'</span>]) // undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。<br>同样的值的两个实例，在 Map 结构中被视为两个键。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">const k1 = [<span class="string">'a'</span>];</span><br><span class="line">const k2 = [<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.<span class="built_in">set</span>(k1, 111)</span><br><span class="line">.<span class="built_in">set</span>(k2, 222);</span><br><span class="line"></span><br><span class="line">map.get(k1) // 111</span><br><span class="line">map.get(k2) // 222</span><br></pre></td></tr></table></figure></p>
<p>另外：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">true</span>, 1);</span><br><span class="line">map.set(<span class="string">'true'</span>, 2);</span><br><span class="line">map.get(<span class="literal">true</span>) // 1</span><br><span class="line"></span><br><span class="line">map.set(undefined, 3);</span><br><span class="line">map.set(null, 4);</span><br><span class="line">map.get(undefined) // 3</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br></pre></td></tr></table></figure></p>
<h4 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h4><p>1、size 属性<br>size属性返回 Map 结构的成员总数<br>2、Map.prototype.set(key, value)<br>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。<br>3、Map.prototype.get(key)<br>get方法读取key对应的键值，如果找不到key，返回undefined。<br>4、Map.prototype.has(key)<br>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。<br>5、Map.prototype.delete(key)<br>delete方法删除某个键，返回true。如果删除失败，返回false。<br>6、Map.prototype.clear()<br>clear方法清除所有成员，没有返回值。</p>
<h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><p>Map.prototype.keys()：返回键名的遍历器。<br>Map.prototype.values()：返回键值的遍历器。<br>Map.prototype.entries()：返回所有成员的遍历器。<br>Map.prototype.forEach()：遍历 Map 的所有成员。</p>
<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [1, <span class="string">'one'</span>],</span><br><span class="line">  [2, <span class="string">'two'</span>],</span><br><span class="line">  [3, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line">// [1, 2, 3]</span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line">// [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line">// [[1,<span class="string">'one'</span>], [2, <span class="string">'two'</span>], [3, <span class="string">'three'</span>]]</span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line">// [[1,<span class="string">'one'</span>], [2, <span class="string">'two'</span>], [3, <span class="string">'three'</span>]]</span><br></pre></td></tr></table></figure></p>
<h4 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h4><p>1、Map 转为数组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const myMap = new Map()</span><br><span class="line">  .<span class="built_in">set</span>(<span class="literal">true</span>, 7)</span><br><span class="line">  .<span class="built_in">set</span>(&#123;foo: 3&#125;, [<span class="string">'abc'</span>]);</span><br><span class="line">[...myMap]</span><br><span class="line">// [ [ <span class="literal">true</span>, 7 ], [ &#123; foo: 3 &#125;, [ <span class="string">'abc'</span> ] ] ]</span><br></pre></td></tr></table></figure></p>
<p>2、数组 转为 Map<br>将数组传入 Map 构造函数，就可以转为 Map。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Map([</span><br><span class="line">  [<span class="literal">true</span>, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [<span class="string">'abc'</span>]]</span><br><span class="line">])</span><br><span class="line">// Map &#123;</span><br><span class="line">//   <span class="literal">true</span> =&gt; 7,</span><br><span class="line">//   Object &#123;foo: 3&#125; =&gt; [<span class="string">'abc'</span>]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、Map 转为对象<br>如果所有 Map 的键都是字符串，它可以无损地转为对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> strMapToObj(strMap) &#123;</span><br><span class="line">  <span class="built_in">let</span> obj = Object.create(null);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myMap = new Map()</span><br><span class="line">  .<span class="built_in">set</span>(<span class="string">'yes'</span>, <span class="literal">true</span>)</span><br><span class="line">  .<span class="built_in">set</span>(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line">// &#123; yes: <span class="literal">true</span>, no: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p>4、对象转为 Map<br>对象转为 Map 可以通过Object.entries()。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;<span class="string">"a"</span>:1, <span class="string">"b"</span>:2&#125;;</span><br><span class="line"><span class="built_in">let</span> map = new Map(Object.entries(obj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//此外，也可以自己实现一个转换函数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> objToStrMap(obj) &#123;</span><br><span class="line">  <span class="built_in">let</span> strMap = new Map();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;yes: <span class="literal">true</span>, no: <span class="literal">false</span>&#125;)</span><br><span class="line">// Map &#123;<span class="string">"yes"</span> =&gt; <span class="literal">true</span>, <span class="string">"no"</span> =&gt; <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>5、Map 转为 JSON<br>Map 转为 JSON 要区分两种情况:<br>一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> strMapToJson(strMap) &#123;</span><br><span class="line">  <span class="built_in">return</span> JSON.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> myMap = new Map().<span class="built_in">set</span>(<span class="string">'yes'</span>, <span class="literal">true</span>).<span class="built_in">set</span>(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line">// <span class="string">'&#123;"yes":true,"no":false&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mapToArrayJson(map) &#123;</span><br><span class="line">  <span class="built_in">return</span> JSON.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> myMap = new Map().<span class="built_in">set</span>(<span class="literal">true</span>, 7).<span class="built_in">set</span>(&#123;foo: 3&#125;, [<span class="string">'abc'</span>]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line">// <span class="string">'[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span></span><br></pre></td></tr></table></figure></p>
<p>6、JSON 转为 Map</p>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> jsonToStrMap(jsonStr) &#123;</span><br><span class="line">  <span class="built_in">return</span> objToStrMap(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">'&#123;"yes": true, "no": false&#125;'</span>)</span><br><span class="line">// Map &#123;<span class="string">'yes'</span> =&gt; <span class="literal">true</span>, <span class="string">'no'</span> =&gt; <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> jsonToMap(jsonStr) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Map(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(<span class="string">'[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span>)</span><br><span class="line">// Map &#123;<span class="literal">true</span> =&gt; 7, Object &#123;foo: 3&#125; =&gt; [<span class="string">'abc'</span>]&#125;</span><br></pre></td></tr></table></figure></p>

                
                <div class="readmore">
                    <a href="/2020/11/23/ES6-2/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2020/10/25/ES6/">
                        ES6（一）
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2020-10-25T11:18:34.000Z">
                            2020-10-25
                        </time>
                    
                    <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li></ul>
                </div>
                
                    <h3 id="🌴-let-与-const"><a href="#🌴-let-与-const" class="headerlink" title="🌴 let 与 const"></a>🌴 let 与 const</h3><h4 id="👉-总结："><a href="#👉-总结：" class="headerlink" title="👉 总结："></a>👉 总结：</h4><ul>
<li>let :声明的变量只在 let 命令所在的代码块内有效，且只能声明一次，多次声明，报错：“Identifier XX has already been declared”,for循环很适合let。</li>
<li>const:声明一个只读的常量，一旦声明，常量的值就不能改变。</li>
</ul>
<h4 id="👉-比较："><a href="#👉-比较：" class="headerlink" title="👉 比较："></a>👉 比较：</h4><p>1、不存在变量提升：let没有预解析，不存在变量提升，var 会变量提升。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // undefined  ===&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class="line">var a = 100;</span><br><span class="line"></span><br><span class="line">console.log(b); // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class="line"><span class="built_in">let</span> b = 10;</span><br><span class="line"></span><br><span class="line">console.log(c); // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br><span class="line">const c = 10;</span><br></pre></td></tr></table></figure>
<p>2、const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。<br>3、暂时性死区：代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。<br>4、var声明的变量会挂载在window上，而let和const声明的变量不会。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">console.log(a,window.a);    // 100 100</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = 10;</span><br><span class="line">console.log(b,window.b);    // 10 undefined</span><br><span class="line"></span><br><span class="line">const c = 1;</span><br><span class="line">console.log(c,window.c);    // 1 undefined</span><br></pre></td></tr></table></figure>
<h4 id="👉-注意"><a href="#👉-注意" class="headerlink" title="👉 注意:"></a>👉 注意:</h4><p>对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。<br>复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<h3 id="🌴-解构赋值"><a href="#🌴-解构赋值" class="headerlink" title="🌴 解构赋值"></a>🌴 解构赋值</h3><p>解构赋值是对赋值运算符的扩展。</p>
<p>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>
<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。<br>在解构中，有下面两部分参与：</p>
<p>解构的源，解构赋值表达式的右边部分。<br>解构的目标，解构赋值表达式的左边部分。</p>
<font color="green">一一对应的关系</font>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [a,b,c] = [1,2,3];</span><br><span class="line"><span class="built_in">let</span> [a,[b,c]] = [1,[2,3]];</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> json = &#123;</span><br><span class="line">    name:<span class="string">'DANDAN'</span>,</span><br><span class="line">    age:18,</span><br><span class="line">    job:<span class="string">"打工人"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;name,age,job&#125; = &#123;</span><br><span class="line">    nama:<span class="string">"DANDAN"</span>,</span><br><span class="line">    age:18,</span><br><span class="line">    job:<span class="string">"打工人"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//别名</span><br><span class="line"><span class="built_in">let</span> &#123;name:n,age:g,job:b&#125; = json</span><br><span class="line">console.log(n,g,b)</span><br><span class="line">//解构可以给默认值</span><br><span class="line"><span class="built_in">let</span> [a,b,c=<span class="string">"暂无数据"</span>] = [1,2,undefined];</span><br><span class="line">//</span><br><span class="line"><span class="built_in">let</span> = a;</span><br><span class="line">(&#123;a&#125; = &#123;a:<span class="string">"apple"</span>,b:<span class="string">"banana"</span>&#125;);</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>
<h3 id="🌴-字符串模板"><a href="#🌴-字符串模板" class="headerlink" title="🌴 字符串模板"></a>🌴 字符串模板</h3><p>代替字符串拼接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name = <span class="string">"DANDAN"</span>;</span><br><span class="line"><span class="built_in">let</span> age = 18;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> str = `我是<span class="variable">$&#123;name&#125;</span>,年龄永远<span class="variable">$&#123;age&#125;</span>岁`;</span><br></pre></td></tr></table></figure></p>
<h3 id="🌴-函数"><a href="#🌴-函数" class="headerlink" title="🌴 函数"></a>🌴 函数</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>函数参数默认已经定义，不能再用let,const声明<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(a=0,b=0)&#123;</span><br><span class="line">    console.log(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>()=&gt;{<br>    语句<br>    return<br>}<br>注:</p>
<ul>
<li>this问题，定义函数所在的对象，不是运行时所在对象。</li>
<li>箭头函数里没有arguments；用“…”。</li>
<li>箭头函数不能作构造函数</li>
</ul>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>扩展运算符，reset运算符(…)：<br>剩余参数必须放到最后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr = [a,b,c]</span><br><span class="line">console.log(...arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> show(...a)&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">show(1,2,3,4,5)</span><br></pre></td></tr></table></figure>
<h3 id="🌴-热闹的数组循环"><a href="#🌴-热闹的数组循环" class="headerlink" title="🌴 热闹的数组循环"></a>🌴 热闹的数组循环</h3><ul>
<li>forEach() 代替for,两个参数</li>
<li>map()</li>
<li>filter()</li>
<li>some()</li>
<li>every()</li>
</ul>
<p>1、arr.forEach(function(){},指向)、arr.map(function(){},指向),接受两个参数，第一个：循环回调函数，第二个：this指向。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="keyword">function</span>(val,index,arr)&#123;</span><br><span class="line">    console.log(this,val,index,arr);</span><br><span class="line">&#125;,windows)</span><br></pre></td></tr></table></figure>
<p>2、arr.map(function(){},指向),和forEach()一样，接受两个参数，第一个：循环回调函数，第二个：this指向。<br>   <font color="red">一般用来做数据交互映射，正常情况下，需要配合return,返回一个新的数组 </font> 若没有return相当于forEach,<br>   日常用return返回目标数据。<br>3、arr.filter(),过滤掉“不合格”数据.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [</span><br><span class="line">    &#123;<span class="built_in">type</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="built_in">type</span>:<span class="literal">false</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="built_in">let</span> newArr = arr.filter(<span class="keyword">function</span>(item,index,arr)&#123;</span><br><span class="line">    <span class="built_in">return</span> item.type === <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newArr);</span><br></pre></td></tr></table></figure>
<p>4、arr.some(),类似查找，数组里面有一个元素符合条件，返回true.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1,2,3,4,5,6];</span><br><span class="line"><span class="built_in">let</span> r = arr.some((val,index,arr) =&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> val%2 = 1;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>5、arr.every(),数组里面所有元素符合条件，返回true。<br>6、arr.reduce(),与上面的不同，有四个参数,从左往右。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> r = arr.reduce((pre,cur,index,arr)=&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> pre+cur;  //求和</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>7、arr.reduceRight(),有四个参数,从右往左。<br>8、for…of</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> val of arr)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> index of arr.keys())&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> item of arr.entries())&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> [key,val] of arr.entries())&#123;</span><br><span class="line">    console.log(key,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🌴-数组新增"><a href="#🌴-数组新增" class="headerlink" title="🌴 数组新增"></a>🌴 数组新增</h3><p>1、Array.from():把类数组对象转为数组。<br>2、Array.of():把一组值转为数组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.of(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>) //[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>]</span><br></pre></td></tr></table></figure>
<p>3、Array.find():数组查找，找出第一个符合条件，若没找到，返回undefined。<br>4、Array.findIndex():返回找到的位置，没找到返回-1.<br>5、arr.fill()<br>6、arr.includes()<br>6、arr.indexOf()</p>
<h3 id="🌴-Promise"><a href="#🌴-Promise" class="headerlink" title="🌴 Promise"></a>🌴 Promise</h3><p>1、解决异步回调问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Promise(<span class="keyword">function</span>(resolve,reject)&#123;</span><br><span class="line">    //resolve成功调用</span><br><span class="line">    //reject 失败调用</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> a=10;</span><br><span class="line"><span class="built_in">let</span> promise = new Promise(<span class="keyword">function</span>(resolve,reject)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==10)&#123;</span><br><span class="line">        resolve(<span class="string">'成功！'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        resolve(<span class="string">'失败！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>2、Promise.resolve(‘a’):将现有的东西转成一个promise对象，resolve状态，成功状态。等价于：new Promise(resolve=&gt;{resolve(“a”)})。<br>Promise.reject(‘a’):将现有的东西转成一个promise对象，reject状态，失败状态。<br>3、Promise.all([p1,p2,p3]):把promise打包，扔到数组里，打包完还是一个promise对象。必须确保所有的promise对象都是resolve状态，都是成功状态。<br>4、Promise.race([p1,p2,p3]):只要有一个成功，就返回。</p>
<h3 id="🌴-模块化"><a href="#🌴-模块化" class="headerlink" title="🌴 模块化"></a>🌴 模块化</h3><p>在ES6之前，社区定制一套模块规范</p>
<ul>
<li>Commonjs—-主要服务端nodejs  require(‘http’)</li>
<li>AMD———requirejs,curljs</li>
<li>CMD———seajs</li>
</ul>
<p>ES6 ， import/export/export default  .</p>
<ul>
<li>可以是相对路径，也可绝对路径。</li>
<li>import只会导入一次，无论引入多少次。</li>
<li>import “./modules/1.js”;如果这么用，相当于引入文件。</li>
<li>import会自动提升到顶部，先执行</li>
<li>导出去模块内容，如果里面有定时器更改，外面也会改动，不像CommonJS规范缓存。</li>
<li>动态引入：类似node里的require，可以动态引入，默认import语法不能写入if之类的里面，返回值是promise对象<br>  优点：1、按需加载；2、可以写if中；3、路径也可以动态。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//1、import、<span class="built_in">export</span></span><br><span class="line">    //模块</span><br><span class="line">        const a=1;</span><br><span class="line">        const b=2;</span><br><span class="line">        <span class="built_in">let</span> c=3</span><br><span class="line">        <span class="built_in">export</span> &#123;</span><br><span class="line">            a as first</span><br><span class="line">            b as second</span><br><span class="line">            c as third</span><br><span class="line">        &#125;</span><br><span class="line">    //引入</span><br><span class="line">        import &#123;first,second,third&#125; from ./modules.js</span><br><span class="line"></span><br><span class="line">//2、import、<span class="built_in">export</span> default</span><br><span class="line">    <span class="built_in">export</span> default引入时不用加花括号.</span><br><span class="line">    //模块</span><br><span class="line">        <span class="built_in">export</span> default a=3;</span><br><span class="line">    //引入</span><br><span class="line">        import a from <span class="string">"./modules.js"</span></span><br><span class="line">//3、动态引入</span><br><span class="line">    import(<span class="string">'./modules.js).then(res=&gt;&#123;</span></span><br><span class="line"><span class="string">        console.log(res.a+res.b);</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Promise.all([import('</span>./1.js<span class="string">'),[import('</span>./2.js<span class="string">')]).then(([res1,res2])=&gt;&#123;</span></span><br><span class="line"><span class="string">        console.log(res1,res2);</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br></pre></td></tr></table></figure>
<h3 id="🌴-Class"><a href="#🌴-Class" class="headerlink" title="🌴 Class"></a>🌴 Class</h3><p>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Point(x, y) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">var p = new Point(1, 2);</span><br><span class="line">//ES6改写</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h4><p>1、constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>2、constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br>3、类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<h4 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h4><p>生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。</p>
<h4 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h4><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</p>
<h4 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h4><p>类的属性名，可以采用表达式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Square类的方法名getArea，是从表达式得到的</span><br><span class="line"><span class="built_in">let</span> methodName = <span class="string">'getArea'</span>;</span><br><span class="line"></span><br><span class="line">class Square &#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Class表达式"><a href="#Class表达式" class="headerlink" title="Class表达式"></a>Class表达式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class Me &#123;</span><br><span class="line">  <span class="function"><span class="title">getClassName</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>1、在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static <span class="function"><span class="title">classMethod</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() // <span class="string">'hello'</span></span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">// TypeError: foo.classMethod is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<p>2、父类的静态方法，可以被子类继承，下节讨论。</p>
<h4 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h4><p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this._count = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  get <span class="function"><span class="title">value</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="built_in">return</span> this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">increment</span></span>() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//也可以</span><br><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  _count = 0;</span><br><span class="line">  get <span class="function"><span class="title">value</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="built_in">return</span> this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">increment</span></span>() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//为Foo类定义了一个静态属性prop。</span><br><span class="line">class Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = 1;</span><br><span class="line">Foo.prop // 1</span><br><span class="line"></span><br><span class="line">//提案</span><br><span class="line">class MyClass &#123;</span><br><span class="line">  static myStaticProp = 42;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    console.log(MyClass.myStaticProp); // 42</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h4><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装。<br>一种做法是在命名上加以区别。下面代码_bar()方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">  // 公有方法</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    this._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line">  // 私有方法</span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">    <span class="built_in">return</span> this.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法就是将私有方法移出类，因为类内部的所有方法都是对外可见的。</p>
<h4 id="私有属性的提案"><a href="#私有属性的提案" class="headerlink" title="私有属性的提案"></a>私有属性的提案</h4><p>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。</p>
<h4 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h4><p>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<p>Class 内部调用new.target，返回当前 Class。<br>子类继承父类时，new.target会返回子类。可以写出不能独立使用、必须继承后才能使用的类。<br>下面代码中，Shape类不能被实例化，只能用于继承。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (new.target === Shape) &#123;</span><br><span class="line">      throw new Error(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle extends Shape &#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    super();</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = new Shape();  // 报错</span><br><span class="line">var y = new Rectangle(3, 4);  // 正确</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  <span class="comment">#count = 0;</span></span><br><span class="line">  get <span class="function"><span class="title">value</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="built_in">return</span> this.<span class="comment">#count;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">increment</span></span>() &#123;</span><br><span class="line">    this.<span class="comment">#count++;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🌴-Class继承（extends）"><a href="#🌴-Class继承（extends）" class="headerlink" title="🌴 Class继承（extends）"></a>🌴 Class继承（extends）</h3><p>1、Class 可以通过extends关键字实现继承。<br>2、子类必须在constructor方法中调用super方法，否则新建实例时会报错。<br>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。<br>3、如果子类没有定义constructor方法，这个方法会被默认添加。<br>4、在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。<br>这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。<br>5、父类的静态方法，也会被子类继承。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    constructor(x, y, color) &#123;</span><br><span class="line">        super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> this.color + <span class="string">' '</span> + super.toString(); // 调用父类的toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3、</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>判断，一个类是否继承了另一个类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point </span><br><span class="line">//<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>当作函数使用，也可以当作对象使用，在这两种情况下，它的用法完全不同。<br>1、第一种情况，super作为函数调用时，super()只能用在子类的构造函数之中,代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。<br>注意：super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。<br>下面，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    console.log(new.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() // A</span><br><span class="line">new B() // B</span><br></pre></td></tr></table></figure></p>
<p>2、第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<p>下面，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。<br>注：super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//1、在普通方法中</span><br><span class="line">class A &#123;</span><br><span class="line">  <span class="function"><span class="title">p</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.p()); // 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> b = new B();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Parent &#123;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    console.log(<span class="string">'static'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    console.log(<span class="string">'instance'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(1); // static 1</span><br><span class="line"></span><br><span class="line">var child = new Child();</span><br><span class="line">child.myMethod(2); // instance 2</span><br></pre></td></tr></table></figure>
<h4 id="类的-prototype-属性和proto属性"><a href="#类的-prototype-属性和proto属性" class="headerlink" title="类的 prototype 属性和proto属性"></a>类的 prototype 属性和<strong>proto</strong>属性</h4><p>ES5 中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。<br>1、子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。<br>2、子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A // <span class="literal">true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h4><p>1、子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。<br>2、通过子类实例的<strong>proto</strong>.<strong>proto</strong>属性，可以修改父类实例的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p2.__proto__.__proto__.printName = function () &#123;</span><br><span class="line">  console.log(&apos;Ha&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // &quot;Ha&quot;</span><br></pre></td></tr></table></figure>
<h3 id="🌴-Symbol"><a href="#🌴-Symbol" class="headerlink" title="🌴 Symbol"></a>🌴 Symbol</h3><p>ES6 数据类型除了 Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol 。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。</p>

                
                <div class="readmore">
                    <a href="/2020/10/25/ES6/">
                        阅读更多
                    </a>
                </div>
            </div>
        
    </div>


    <div id="content-aside">
    <div class="content-aside-owner">
        <div id="owner">
    <div class="avatar-bg">
        <div class="index-page">
            <div class="banner">
                <div class="slide slide1">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_left">
                            <div id="canvas_left"></div>
                        </div>
                    </div>
                </div>
                <div class="slide slide2">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_right">
                            <div id="canvas_right"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a href="/"><img class="avatar" src="/images/avatar.jpg" alt=""></a>
    <a href="/"><h3 class="author">I&#39;m xiedandan</h3></a>
    <h4>^_^</h4>
    <div class="social">
        
            
              <a href="https://github.com/xdd7130" title="github" class="fa fa-github" target="_blank"></a>
            
        
            
              <a href="#" title="weibo" class="fa fa-weibo" target="_blank"></a>
            
        
    </div>
</div>
    </div>
    
        <div class="content-aside-about">
            <h2>
                <a href="/about">关于</a>
            </h2>
        </div>
    
    <div class="content-aside-tags">
        <h2>
            <a href="/tags">
                标签
                <sup style="font-size: 12px">
                    [32]
                </sup>
            </a>
        </h2>
    </div>
    
<aside id="categories">
    <h2>分类</h2>
    
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ArcGIS/">ArcGIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cesium/">Cesium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础前端技术/">基础前端技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小程序/">小程序</a></li></ul>
    
</aside>

    
<aside id="acchives">
    <h2>归档</h2>
    
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    
</aside>

</div>

</div>
<nav id="pagination" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
</nav>

    </div>
</div>
<footer id="footer">
     <div id="copyright">&copy; I&#39;m xiedandan  2021</div>
     
             <!-- 不蒜子统计 -->
             <span id="busuanzi_container_site_pv">
                     本站总访问量<span id="busuanzi_value_site_pv" style='color:#17a167'></span>次
             </span>
             <span class="post-meta-divider">|</span>
             <span id="busuanzi_container_site_uv">
                     本站访客数<span id="busuanzi_value_site_uv"  style='color:#17a167'></span>人
             </span>
             <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
       
    <div id="theme">
        Powered by <a href="http://hexo.io">Hexo</a>. Theme by <a href="https://github.com/markyong/hexo-theme-stage">Stage</a>
    </div>
</footer>
<script src="/lib/js/waterrippleeffect.min.js"></script>
<script src="/js/header-bg.main.js"></script>

    <script src="/lib/js/cav.js"></script>
    <script src="/js/avatar-bg.main.js"></script>

</body>
</html>
